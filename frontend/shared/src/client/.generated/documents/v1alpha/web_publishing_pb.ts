// @generated by protoc-gen-es v1.0.0 with parameter "target=ts,import_extension=none"
// @generated from file documents/v1alpha/web_publishing.proto (package com.mintter.documents.v1alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Publication } from "./documents_pb";

/**
 * Request to add a site.
 *
 * @generated from message com.mintter.documents.v1alpha.AddSiteRequest
 */
export class AddSiteRequest extends Message<AddSiteRequest> {
  /**
   * Required. Site hostname.
   *
   * @generated from field: string hostname = 1;
   */
  hostname = "";

  /**
   * Optional. Invite token for the site. Not needed
   * if the site already knows our Account ID.
   *
   * @generated from field: string invite_token = 2;
   */
  inviteToken = "";

  constructor(data?: PartialMessage<AddSiteRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.AddSiteRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "invite_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddSiteRequest {
    return new AddSiteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddSiteRequest {
    return new AddSiteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddSiteRequest {
    return new AddSiteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AddSiteRequest | PlainMessage<AddSiteRequest> | undefined, b: AddSiteRequest | PlainMessage<AddSiteRequest> | undefined): boolean {
    return proto3.util.equals(AddSiteRequest, a, b);
  }
}

/**
 * Request to remove a site from the local app backend.
 *
 * @generated from message com.mintter.documents.v1alpha.RemoveSiteRequest
 */
export class RemoveSiteRequest extends Message<RemoveSiteRequest> {
  /**
   * Required. Site hostname.
   *
   * @generated from field: string hostname = 1;
   */
  hostname = "";

  constructor(data?: PartialMessage<RemoveSiteRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.RemoveSiteRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveSiteRequest {
    return new RemoveSiteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveSiteRequest {
    return new RemoveSiteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveSiteRequest {
    return new RemoveSiteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveSiteRequest | PlainMessage<RemoveSiteRequest> | undefined, b: RemoveSiteRequest | PlainMessage<RemoveSiteRequest> | undefined): boolean {
    return proto3.util.equals(RemoveSiteRequest, a, b);
  }
}

/**
 * Request to list configured sites.
 *
 * @generated from message com.mintter.documents.v1alpha.ListSitesRequest
 */
export class ListSitesRequest extends Message<ListSitesRequest> {
  /**
   * Optional. Number of items per page.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. Token for a specific page.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListSitesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListSitesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSitesRequest {
    return new ListSitesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSitesRequest {
    return new ListSitesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSitesRequest {
    return new ListSitesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSitesRequest | PlainMessage<ListSitesRequest> | undefined, b: ListSitesRequest | PlainMessage<ListSitesRequest> | undefined): boolean {
    return proto3.util.equals(ListSitesRequest, a, b);
  }
}

/**
 * Response with a list of sites.
 *
 * @generated from message com.mintter.documents.v1alpha.ListSitesResponse
 */
export class ListSitesResponse extends Message<ListSitesResponse> {
  /**
   * List of sites.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.SiteConfig sites = 1;
   */
  sites: SiteConfig[] = [];

  /**
   * Token for the next page if any.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListSitesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListSitesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sites", kind: "message", T: SiteConfig, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSitesResponse {
    return new ListSitesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSitesResponse {
    return new ListSitesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSitesResponse {
    return new ListSitesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSitesResponse | PlainMessage<ListSitesResponse> | undefined, b: ListSitesResponse | PlainMessage<ListSitesResponse> | undefined): boolean {
    return proto3.util.equals(ListSitesResponse, a, b);
  }
}

/**
 * Request to a list publication records for a given document
 * among the configured web sites.
 *
 * @generated from message com.mintter.documents.v1alpha.ListWebPublicationRecordsRequest
 */
export class ListWebPublicationRecordsRequest extends Message<ListWebPublicationRecordsRequest> {
  /**
   * Required. Document ID.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  /**
   * Optional. Specific version of a document.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<ListWebPublicationRecordsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListWebPublicationRecordsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWebPublicationRecordsRequest {
    return new ListWebPublicationRecordsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWebPublicationRecordsRequest {
    return new ListWebPublicationRecordsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWebPublicationRecordsRequest {
    return new ListWebPublicationRecordsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListWebPublicationRecordsRequest | PlainMessage<ListWebPublicationRecordsRequest> | undefined, b: ListWebPublicationRecordsRequest | PlainMessage<ListWebPublicationRecordsRequest> | undefined): boolean {
    return proto3.util.equals(ListWebPublicationRecordsRequest, a, b);
  }
}

/**
 * Response with a list of publication records among the web sites.
 *
 * @generated from message com.mintter.documents.v1alpha.ListWebPublicationRecordsResponse
 */
export class ListWebPublicationRecordsResponse extends Message<ListWebPublicationRecordsResponse> {
  /**
   * @generated from field: repeated com.mintter.documents.v1alpha.WebPublicationRecord publications = 1;
   */
  publications: WebPublicationRecord[] = [];

  constructor(data?: PartialMessage<ListWebPublicationRecordsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListWebPublicationRecordsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "publications", kind: "message", T: WebPublicationRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWebPublicationRecordsResponse {
    return new ListWebPublicationRecordsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWebPublicationRecordsResponse {
    return new ListWebPublicationRecordsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWebPublicationRecordsResponse {
    return new ListWebPublicationRecordsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListWebPublicationRecordsResponse | PlainMessage<ListWebPublicationRecordsResponse> | undefined, b: ListWebPublicationRecordsResponse | PlainMessage<ListWebPublicationRecordsResponse> | undefined): boolean {
    return proto3.util.equals(ListWebPublicationRecordsResponse, a, b);
  }
}

/**
 * Local site configuration.
 *
 * @generated from message com.mintter.documents.v1alpha.SiteConfig
 */
export class SiteConfig extends Message<SiteConfig> {
  /**
   * Hostname of the site.
   *
   * @generated from field: string hostname = 1;
   */
  hostname = "";

  /**
   * Our role on this site.
   *
   * @generated from field: com.mintter.documents.v1alpha.Member.Role role = 2;
   */
  role = Member_Role.ROLE_UNSPECIFIED;

  constructor(data?: PartialMessage<SiteConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.SiteConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "role", kind: "enum", T: proto3.getEnumType(Member_Role) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SiteConfig {
    return new SiteConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SiteConfig {
    return new SiteConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SiteConfig {
    return new SiteConfig().fromJsonString(jsonString, options);
  }

  static equals(a: SiteConfig | PlainMessage<SiteConfig> | undefined, b: SiteConfig | PlainMessage<SiteConfig> | undefined): boolean {
    return proto3.util.equals(SiteConfig, a, b);
  }
}

/**
 * Member of the web site.
 *
 * @generated from message com.mintter.documents.v1alpha.Member
 */
export class Member extends Message<Member> {
  /**
   * Mintter Account ID of the member.
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * Member's role on the site.
   *
   * @generated from field: com.mintter.documents.v1alpha.Member.Role role = 2;
   */
  role = Member_Role.ROLE_UNSPECIFIED;

  constructor(data?: PartialMessage<Member>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.Member";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "role", kind: "enum", T: proto3.getEnumType(Member_Role) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Member {
    return new Member().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJsonString(jsonString, options);
  }

  static equals(a: Member | PlainMessage<Member> | undefined, b: Member | PlainMessage<Member> | undefined): boolean {
    return proto3.util.equals(Member, a, b);
  }
}

/**
 * Roles a member of the Mintter Site can have.
 *
 * @generated from enum com.mintter.documents.v1alpha.Member.Role
 */
export enum Member_Role {
  /**
   * Invalid default value.
   *
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  ROLE_UNSPECIFIED = 0,

  /**
   * Currently there can only be one owner of the site.
   *
   * @generated from enum value: OWNER = 1;
   */
  OWNER = 1,

  /**
   * Editors are allowed to push content to the site.
   *
   * @generated from enum value: EDITOR = 2;
   */
  EDITOR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Member_Role)
proto3.util.setEnumType(Member_Role, "com.mintter.documents.v1alpha.Member.Role", [
  { no: 0, name: "ROLE_UNSPECIFIED" },
  { no: 1, name: "OWNER" },
  { no: 2, name: "EDITOR" },
]);

/**
 * Information about a Mintter Document published on a Mintter Site.
 * One Document ID can be published with different versions and/or
 * under different paths on a Mintter Web Site, so it can have
 * multiple of these records per site.
 *
 * @generated from message com.mintter.documents.v1alpha.WebPublicationRecord
 */
export class WebPublicationRecord extends Message<WebPublicationRecord> {
  /**
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: string hostname = 3;
   */
  hostname = "";

  /**
   * @generated from field: string path = 4;
   */
  path = "";

  constructor(data?: PartialMessage<WebPublicationRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.WebPublicationRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebPublicationRecord {
    return new WebPublicationRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebPublicationRecord {
    return new WebPublicationRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebPublicationRecord {
    return new WebPublicationRecord().fromJsonString(jsonString, options);
  }

  static equals(a: WebPublicationRecord | PlainMessage<WebPublicationRecord> | undefined, b: WebPublicationRecord | PlainMessage<WebPublicationRecord> | undefined): boolean {
    return proto3.util.equals(WebPublicationRecord, a, b);
  }
}

/**
 * Request to create a new invite token.
 *
 * @generated from message com.mintter.documents.v1alpha.CreateInviteTokenRequest
 */
export class CreateInviteTokenRequest extends Message<CreateInviteTokenRequest> {
  /**
   * Required. The role to be associated with the new member after invite is redeemed.
   * The server might be configured to limit invites for certain roles, but it's not
   * restricted in this API definition.
   *
   * @generated from field: com.mintter.documents.v1alpha.Member.Role role = 1;
   */
  role = Member_Role.ROLE_UNSPECIFIED;

  /**
   * Optional. The timestamp after which the invite token will expire if not redeemed.
   * If not provided, the server will decide the deadline based on the internal configuration.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 2;
   */
  expireTime?: Timestamp;

  constructor(data?: PartialMessage<CreateInviteTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.CreateInviteTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role", kind: "enum", T: proto3.getEnumType(Member_Role) },
    { no: 2, name: "expire_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInviteTokenRequest {
    return new CreateInviteTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInviteTokenRequest {
    return new CreateInviteTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInviteTokenRequest {
    return new CreateInviteTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInviteTokenRequest | PlainMessage<CreateInviteTokenRequest> | undefined, b: CreateInviteTokenRequest | PlainMessage<CreateInviteTokenRequest> | undefined): boolean {
    return proto3.util.equals(CreateInviteTokenRequest, a, b);
  }
}

/**
 * Request to redeem an invite token. This is the most security-sensitive request,
 * because it allows to register new members on the site. The server must obtain
 * and verify the relation of the communicating peer with a corresponding Mintter Account.
 * After the token is redeemed, a new member on the site must be created, associating
 * the Mintter Account of the caller with the role invite token was created for.
 *
 * @generated from message com.mintter.documents.v1alpha.RedeemInviteTokenRequest
 */
export class RedeemInviteTokenRequest extends Message<RedeemInviteTokenRequest> {
  /**
   * Value of the invite token.
   *
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<RedeemInviteTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.RedeemInviteTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedeemInviteTokenRequest {
    return new RedeemInviteTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedeemInviteTokenRequest {
    return new RedeemInviteTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedeemInviteTokenRequest {
    return new RedeemInviteTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RedeemInviteTokenRequest | PlainMessage<RedeemInviteTokenRequest> | undefined, b: RedeemInviteTokenRequest | PlainMessage<RedeemInviteTokenRequest> | undefined): boolean {
    return proto3.util.equals(RedeemInviteTokenRequest, a, b);
  }
}

/**
 * Response after the token is redeemed.
 *
 * @generated from message com.mintter.documents.v1alpha.RedeemInviteTokenResponse
 */
export class RedeemInviteTokenResponse extends Message<RedeemInviteTokenResponse> {
  /**
   * The role associated with the redeemed token
   *
   * @generated from field: com.mintter.documents.v1alpha.Member.Role role = 1;
   */
  role = Member_Role.ROLE_UNSPECIFIED;

  constructor(data?: PartialMessage<RedeemInviteTokenResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.RedeemInviteTokenResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role", kind: "enum", T: proto3.getEnumType(Member_Role) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedeemInviteTokenResponse {
    return new RedeemInviteTokenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedeemInviteTokenResponse {
    return new RedeemInviteTokenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedeemInviteTokenResponse {
    return new RedeemInviteTokenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RedeemInviteTokenResponse | PlainMessage<RedeemInviteTokenResponse> | undefined, b: RedeemInviteTokenResponse | PlainMessage<RedeemInviteTokenResponse> | undefined): boolean {
    return proto3.util.equals(RedeemInviteTokenResponse, a, b);
  }
}

/**
 * Request to get the site info.
 *
 * @generated from message com.mintter.documents.v1alpha.GetSiteInfoRequest
 */
export class GetSiteInfoRequest extends Message<GetSiteInfoRequest> {
  constructor(data?: PartialMessage<GetSiteInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.GetSiteInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSiteInfoRequest {
    return new GetSiteInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSiteInfoRequest {
    return new GetSiteInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSiteInfoRequest {
    return new GetSiteInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSiteInfoRequest | PlainMessage<GetSiteInfoRequest> | undefined, b: GetSiteInfoRequest | PlainMessage<GetSiteInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetSiteInfoRequest, a, b);
  }
}

/**
 * Request to update site info. Doesn't support partial updates.
 *
 * @generated from message com.mintter.documents.v1alpha.UpdateSiteInfoRequest
 */
export class UpdateSiteInfoRequest extends Message<UpdateSiteInfoRequest> {
  /**
   * Title of the site.
   *
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * Description of the site.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  constructor(data?: PartialMessage<UpdateSiteInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.UpdateSiteInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSiteInfoRequest {
    return new UpdateSiteInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSiteInfoRequest {
    return new UpdateSiteInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSiteInfoRequest {
    return new UpdateSiteInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSiteInfoRequest | PlainMessage<UpdateSiteInfoRequest> | undefined, b: UpdateSiteInfoRequest | PlainMessage<UpdateSiteInfoRequest> | undefined): boolean {
    return proto3.util.equals(UpdateSiteInfoRequest, a, b);
  }
}

/**
 * Request to list site members.
 *
 * @generated from message com.mintter.documents.v1alpha.ListMembersRequest
 */
export class ListMembersRequest extends Message<ListMembersRequest> {
  /**
   * Optional. Number of items per page.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. Token for a specific page.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListMembersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListMembersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListMembersRequest | PlainMessage<ListMembersRequest> | undefined, b: ListMembersRequest | PlainMessage<ListMembersRequest> | undefined): boolean {
    return proto3.util.equals(ListMembersRequest, a, b);
  }
}

/**
 * Response listing site members.
 *
 * @generated from message com.mintter.documents.v1alpha.ListMembersResponse
 */
export class ListMembersResponse extends Message<ListMembersResponse> {
  /**
   * List of members.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.Member members = 1;
   */
  members: Member[] = [];

  /**
   * Optional token for the next page.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListMembersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListMembersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "members", kind: "message", T: Member, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListMembersResponse | PlainMessage<ListMembersResponse> | undefined, b: ListMembersResponse | PlainMessage<ListMembersResponse> | undefined): boolean {
    return proto3.util.equals(ListMembersResponse, a, b);
  }
}

/**
 * Request to get information about a specific member.
 *
 * @generated from message com.mintter.documents.v1alpha.GetMemberRequest
 */
export class GetMemberRequest extends Message<GetMemberRequest> {
  /**
   * Required. Mintter Account ID to get the information for.
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  constructor(data?: PartialMessage<GetMemberRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.GetMemberRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMemberRequest {
    return new GetMemberRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMemberRequest {
    return new GetMemberRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMemberRequest {
    return new GetMemberRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetMemberRequest | PlainMessage<GetMemberRequest> | undefined, b: GetMemberRequest | PlainMessage<GetMemberRequest> | undefined): boolean {
    return proto3.util.equals(GetMemberRequest, a, b);
  }
}

/**
 * Request to delete an existing member.
 *
 * @generated from message com.mintter.documents.v1alpha.DeleteMemberRequest
 */
export class DeleteMemberRequest extends Message<DeleteMemberRequest> {
  /**
   * Required. Mintter Account ID of the member to be deleted.
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  constructor(data?: PartialMessage<DeleteMemberRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.DeleteMemberRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteMemberRequest {
    return new DeleteMemberRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteMemberRequest {
    return new DeleteMemberRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteMemberRequest {
    return new DeleteMemberRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteMemberRequest | PlainMessage<DeleteMemberRequest> | undefined, b: DeleteMemberRequest | PlainMessage<DeleteMemberRequest> | undefined): boolean {
    return proto3.util.equals(DeleteMemberRequest, a, b);
  }
}

/**
 * Request to publish a Mintter Document on a Mintter Web Site.
 *
 * @generated from message com.mintter.documents.v1alpha.PublishDocumentRequest
 */
export class PublishDocumentRequest extends Message<PublishDocumentRequest> {
  /**
   * Required. ID of the document to publish.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  /**
   * Required. Specific version of the document to publish.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Required. Path for the URL of this document on the web site.
   *
   * @generated from field: string path = 3;
   */
  path = "";

  /**
   * List of other supporting materials that are necessary
   * to properly render the document being published.
   * Namely, originals that are transcluded (or possibly linked)
   * in the document being published.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.ReferencedDocument referenced_documents = 4;
   */
  referencedDocuments: ReferencedDocument[] = [];

  constructor(data?: PartialMessage<PublishDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.PublishDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "referenced_documents", kind: "message", T: ReferencedDocument, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishDocumentRequest {
    return new PublishDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishDocumentRequest {
    return new PublishDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishDocumentRequest {
    return new PublishDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PublishDocumentRequest | PlainMessage<PublishDocumentRequest> | undefined, b: PublishDocumentRequest | PlainMessage<PublishDocumentRequest> | undefined): boolean {
    return proto3.util.equals(PublishDocumentRequest, a, b);
  }
}

/**
 * Response when publishing a document.
 *
 * @generated from message com.mintter.documents.v1alpha.PublishDocumentResponse
 */
export class PublishDocumentResponse extends Message<PublishDocumentResponse> {
  constructor(data?: PartialMessage<PublishDocumentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.PublishDocumentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishDocumentResponse {
    return new PublishDocumentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishDocumentResponse {
    return new PublishDocumentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishDocumentResponse {
    return new PublishDocumentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PublishDocumentResponse | PlainMessage<PublishDocumentResponse> | undefined, b: PublishDocumentResponse | PlainMessage<PublishDocumentResponse> | undefined): boolean {
    return proto3.util.equals(PublishDocumentResponse, a, b);
  }
}

/**
 * Request to unpublish a document from a site.
 *
 * @generated from message com.mintter.documents.v1alpha.UnpublishDocumentRequest
 */
export class UnpublishDocumentRequest extends Message<UnpublishDocumentRequest> {
  /**
   * Required. Document ID to unpublish from the web site.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  /**
   * Optional. Specific version to unpublish from the web site.
   * If empty, all versions should be unpublished.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<UnpublishDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.UnpublishDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnpublishDocumentRequest {
    return new UnpublishDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnpublishDocumentRequest {
    return new UnpublishDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnpublishDocumentRequest {
    return new UnpublishDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnpublishDocumentRequest | PlainMessage<UnpublishDocumentRequest> | undefined, b: UnpublishDocumentRequest | PlainMessage<UnpublishDocumentRequest> | undefined): boolean {
    return proto3.util.equals(UnpublishDocumentRequest, a, b);
  }
}

/**
 * Response after unpublishing a web publication.
 *
 * @generated from message com.mintter.documents.v1alpha.UnpublishDocumentResponse
 */
export class UnpublishDocumentResponse extends Message<UnpublishDocumentResponse> {
  constructor(data?: PartialMessage<UnpublishDocumentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.UnpublishDocumentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnpublishDocumentResponse {
    return new UnpublishDocumentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnpublishDocumentResponse {
    return new UnpublishDocumentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnpublishDocumentResponse {
    return new UnpublishDocumentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnpublishDocumentResponse | PlainMessage<UnpublishDocumentResponse> | undefined, b: UnpublishDocumentResponse | PlainMessage<UnpublishDocumentResponse> | undefined): boolean {
    return proto3.util.equals(UnpublishDocumentResponse, a, b);
  }
}

/**
 * Request to list documents published on a web site.
 *
 * @generated from message com.mintter.documents.v1alpha.ListWebPublicationsRequest
 */
export class ListWebPublicationsRequest extends Message<ListWebPublicationsRequest> {
  /**
   * Number of items per page.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Token for a specific page.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListWebPublicationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListWebPublicationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWebPublicationsRequest {
    return new ListWebPublicationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWebPublicationsRequest {
    return new ListWebPublicationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWebPublicationsRequest {
    return new ListWebPublicationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListWebPublicationsRequest | PlainMessage<ListWebPublicationsRequest> | undefined, b: ListWebPublicationsRequest | PlainMessage<ListWebPublicationsRequest> | undefined): boolean {
    return proto3.util.equals(ListWebPublicationsRequest, a, b);
  }
}

/**
 * Response of all documents published on a web site.
 * A single Document ID can have multiple publication records
 * under different paths, and/or with different versions.
 *
 * @generated from message com.mintter.documents.v1alpha.ListWebPublicationsResponse
 */
export class ListWebPublicationsResponse extends Message<ListWebPublicationsResponse> {
  /**
   * @generated from field: repeated com.mintter.documents.v1alpha.WebPublicationRecord publications = 1;
   */
  publications: WebPublicationRecord[] = [];

  constructor(data?: PartialMessage<ListWebPublicationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListWebPublicationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "publications", kind: "message", T: WebPublicationRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListWebPublicationsResponse {
    return new ListWebPublicationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListWebPublicationsResponse {
    return new ListWebPublicationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListWebPublicationsResponse {
    return new ListWebPublicationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListWebPublicationsResponse | PlainMessage<ListWebPublicationsResponse> | undefined, b: ListWebPublicationsResponse | PlainMessage<ListWebPublicationsResponse> | undefined): boolean {
    return proto3.util.equals(ListWebPublicationsResponse, a, b);
  }
}

/**
 * Invite token is produced by the owner of the site to invite new members.
 *
 * @generated from message com.mintter.documents.v1alpha.InviteToken
 */
export class InviteToken extends Message<InviteToken> {
  /**
   * The value of the invite token.
   *
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * Timestamp after which the token will not be recognized by the site.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 2;
   */
  expireTime?: Timestamp;

  constructor(data?: PartialMessage<InviteToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.InviteToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expire_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InviteToken {
    return new InviteToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InviteToken {
    return new InviteToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InviteToken {
    return new InviteToken().fromJsonString(jsonString, options);
  }

  static equals(a: InviteToken | PlainMessage<InviteToken> | undefined, b: InviteToken | PlainMessage<InviteToken> | undefined): boolean {
    return proto3.util.equals(InviteToken, a, b);
  }
}

/**
 * Public-facing information about the Mintter Site.
 *
 * @generated from message com.mintter.documents.v1alpha.SiteInfo
 */
export class SiteInfo extends Message<SiteInfo> {
  /**
   * Hostname under which this site is exposed.
   *
   * @generated from field: string hostname = 1;
   */
  hostname = "";

  /**
   * Title of this site.
   *
   * @generated from field: string title = 2;
   */
  title = "";

  /**
   * Description of this site.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Mintter Account ID that is configured as the owner of this site.
   *
   * @generated from field: string owner = 4;
   */
  owner = "";

  constructor(data?: PartialMessage<SiteInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.SiteInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "owner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SiteInfo {
    return new SiteInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SiteInfo {
    return new SiteInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SiteInfo {
    return new SiteInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SiteInfo | PlainMessage<SiteInfo> | undefined, b: SiteInfo | PlainMessage<SiteInfo> | undefined): boolean {
    return proto3.util.equals(SiteInfo, a, b);
  }
}

/**
 * Response for the /.well-known discovery HTTP page.
 * TODO: define the actual /.well-known path.
 *
 * TODO: add the necessary fields to export under the /.well-known HTTP discovery path.
 *
 * @generated from message com.mintter.documents.v1alpha.SiteDiscoveryConfig
 */
export class SiteDiscoveryConfig extends Message<SiteDiscoveryConfig> {
  constructor(data?: PartialMessage<SiteDiscoveryConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.SiteDiscoveryConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SiteDiscoveryConfig {
    return new SiteDiscoveryConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SiteDiscoveryConfig {
    return new SiteDiscoveryConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SiteDiscoveryConfig {
    return new SiteDiscoveryConfig().fromJsonString(jsonString, options);
  }

  static equals(a: SiteDiscoveryConfig | PlainMessage<SiteDiscoveryConfig> | undefined, b: SiteDiscoveryConfig | PlainMessage<SiteDiscoveryConfig> | undefined): boolean {
    return proto3.util.equals(SiteDiscoveryConfig, a, b);
  }
}

/**
 * Description of "referenced" materials that go along
 * with a Mintter Document being published on a Web Site.
 *
 * @generated from message com.mintter.documents.v1alpha.ReferencedDocument
 */
export class ReferencedDocument extends Message<ReferencedDocument> {
  /**
   * Required. ID of the document.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  /**
   * Required. Specific version of the document.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<ReferencedDocument>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ReferencedDocument";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReferencedDocument {
    return new ReferencedDocument().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReferencedDocument {
    return new ReferencedDocument().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReferencedDocument {
    return new ReferencedDocument().fromJsonString(jsonString, options);
  }

  static equals(a: ReferencedDocument | PlainMessage<ReferencedDocument> | undefined, b: ReferencedDocument | PlainMessage<ReferencedDocument> | undefined): boolean {
    return proto3.util.equals(ReferencedDocument, a, b);
  }
}

/**
 * @generated from message com.mintter.documents.v1alpha.GetPathRequest
 */
export class GetPathRequest extends Message<GetPathRequest> {
  /**
   * Get doc by path. Empty string === home/root doc.
   *
   * @generated from field: string path = 1;
   */
  path = "";

  constructor(data?: PartialMessage<GetPathRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.GetPathRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPathRequest {
    return new GetPathRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPathRequest {
    return new GetPathRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPathRequest {
    return new GetPathRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPathRequest | PlainMessage<GetPathRequest> | undefined, b: GetPathRequest | PlainMessage<GetPathRequest> | undefined): boolean {
    return proto3.util.equals(GetPathRequest, a, b);
  }
}

/**
 * @generated from message com.mintter.documents.v1alpha.GetPathResponse
 */
export class GetPathResponse extends Message<GetPathResponse> {
  /**
   * Publication
   *
   * @generated from field: com.mintter.documents.v1alpha.Publication publication = 1;
   */
  publication?: Publication;

  constructor(data?: PartialMessage<GetPathResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.GetPathResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "publication", kind: "message", T: Publication },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPathResponse {
    return new GetPathResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPathResponse {
    return new GetPathResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPathResponse {
    return new GetPathResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetPathResponse | PlainMessage<GetPathResponse> | undefined, b: GetPathResponse | PlainMessage<GetPathResponse> | undefined): boolean {
    return proto3.util.equals(GetPathResponse, a, b);
  }
}

