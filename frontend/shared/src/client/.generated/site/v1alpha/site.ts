// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
//@ts-nocheck
/* eslint-disable */
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import _m0 from "protobufjs/minimal";
import { Empty } from "../../google/protobuf/empty";
import { Timestamp } from "../../google/protobuf/timestamp";

/** Request to create a new invite token. */
export interface CreateInviteTokenRequest {
  /**
   * Required. The role to be associated with the new member after invite is redeemed.
   * The server might be configured to limit invites for certain roles, but it's not
   * restricted in this API definition.
   */
  role: Member_Role;
  /**
   * Optional. The timestamp after which the invite token will expire if not redeemed.
   * If not provided, the server will decide the deadline based on the internal configuration.
   */
  expireTime: Date | undefined;
}

/**
 * Request to redeem an invite token. This is the most security-sensitive request,
 * because it allows to register new members on the site. The server must obtain
 * and verify the relation of the communicating peer with a corresponding Mintter Account.
 * After the token is redeemed, a new member on the site must be created, associating
 * the Mintter Account of the caller with the role invite token was created for.
 */
export interface RedeemInviteTokenRequest {
  /** Value of the invite token. */
  token: string;
  /** Mintter Account ID of the new member. */
  accountId: string;
  /** Mintter Device ID of the new member. */
  deviceId: string;
}

/** Response after the token is redeemed. */
export interface RedeemInviteTokenResponse {
}

/** Request to get the site info. */
export interface GetSiteInfoRequest {
}

/** Request to update site info. Doesn't support partial updates. */
export interface UpdateSiteInfoRequest {
  /** Title of the site. */
  title: string;
  /** Description of the site. */
  description: string;
}

/** Request to list site members. */
export interface ListMembersRequest {
  /** Optional. Number of items per page. */
  pageSize: number;
  /** Optional. Token for a specific page. */
  pageToken: string;
}

/** Response listing site members. */
export interface ListMembersResponse {
  /** List of members. */
  members: Member[];
  /** Optional token for the next page. */
  nextPageToken: string;
}

/** Request to get information about a specific member. */
export interface GetMemberRequest {
  /** Required. Mintter Account ID to get the information for. */
  accountId: string;
}

/** Request to delete an existing member. */
export interface DeleteMemberRequest {
  /** Required. Mintter Account ID of the member to be deleted. */
  accountId: string;
}

/**
 * Request to block a specific Mintter Account.
 * The server is free to decide how the block list is handled,
 * and what happens when an existing member is being blocked.
 */
export interface BlockAccountRequest {
  /** Required. Mintter Account ID to be blocked. */
  accountId: string;
}

/** Response after blocking an Account. */
export interface BlockAccountResponse {
}

/** Request to unblock an Account. */
export interface UnblockAccountRequest {
  /** Required. Mintter Account ID to be unblocked. */
  accountId: string;
}

/** Response after unblocking an Account. */
export interface UnblockAccountResponse {
}

/** Request to list blocked accounts. */
export interface ListBlockedAccountsRequest {
  /** Optional. Number of items per page. */
  pageSize: number;
  /** Options. Token for a specific page if any. */
  nextPageToken: string;
}

/** Response with a list of blocked accounts. */
export interface ListBlockedAccountsResponse {
  /** List of blocked accounts. */
  accounts: string[];
  /** Token for the next page if any. */
  nextPageToken: string;
}

/** Invite token is produced by the owner of the site to invite new members. */
export interface InviteToken {
  /** The value of the invite token. */
  token: string;
  /** Timestamp after which the token will not be recognized by the site. */
  expireTime: Date | undefined;
}

/** Public-facing information about the Mintter Site. */
export interface SiteInfo {
  /** Hostname under which this site is exposed. */
  hostname: string;
  /** Title of this site. */
  title: string;
  /** Description of this site. */
  description: string;
  /** Mintter Account ID that is configured as the owner of this site. */
  owner: string;
}

/** Member of the site. */
export interface Member {
  /** Mintter Account ID of the member. */
  accountId: string;
  /** Member's role on the site. */
  role: Member_Role;
}

/** Roles a member of the Mintter Site can have. */
export enum Member_Role {
  /** ROLE_UNSPECIFIED - Invalid default value. */
  ROLE_UNSPECIFIED = 0,
  /** OWNER - Currently there can only be one owner of the site. */
  OWNER = 1,
  /** EDITOR - Editors are allowed to push content to the site. */
  EDITOR = 2,
  UNRECOGNIZED = -1,
}

export function member_RoleFromJSON(object: any): Member_Role {
  switch (object) {
    case 0:
    case "ROLE_UNSPECIFIED":
      return Member_Role.ROLE_UNSPECIFIED;
    case 1:
    case "OWNER":
      return Member_Role.OWNER;
    case 2:
    case "EDITOR":
      return Member_Role.EDITOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Member_Role.UNRECOGNIZED;
  }
}

export function member_RoleToJSON(object: Member_Role): string {
  switch (object) {
    case Member_Role.ROLE_UNSPECIFIED:
      return "ROLE_UNSPECIFIED";
    case Member_Role.OWNER:
      return "OWNER";
    case Member_Role.EDITOR:
      return "EDITOR";
    case Member_Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Response for the /.well-known discovery HTTP page.
 * TODO: define the actual /.well-known path.
 */
export interface DiscoveryConfig {
}

function createBaseCreateInviteTokenRequest(): CreateInviteTokenRequest {
  return { role: 0, expireTime: undefined };
}

export const CreateInviteTokenRequest = {
  encode(message: CreateInviteTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role !== 0) {
      writer.uint32(8).int32(message.role);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateInviteTokenRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInviteTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.role = reader.int32() as any;
          break;
        case 2:
          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateInviteTokenRequest {
    return {
      role: isSet(object.role) ? member_RoleFromJSON(object.role) : 0,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: CreateInviteTokenRequest): unknown {
    const obj: any = {};
    message.role !== undefined && (obj.role = member_RoleToJSON(message.role));
    message.expireTime !== undefined && (obj.expireTime = message.expireTime.toISOString());
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CreateInviteTokenRequest>, I>>(object: I): CreateInviteTokenRequest {
    const message = createBaseCreateInviteTokenRequest();
    message.role = object.role ?? 0;
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseRedeemInviteTokenRequest(): RedeemInviteTokenRequest {
  return { token: "", accountId: "", deviceId: "" };
}

export const RedeemInviteTokenRequest = {
  encode(message: RedeemInviteTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    if (message.deviceId !== "") {
      writer.uint32(26).string(message.deviceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RedeemInviteTokenRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedeemInviteTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        case 2:
          message.accountId = reader.string();
          break;
        case 3:
          message.deviceId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RedeemInviteTokenRequest {
    return {
      token: isSet(object.token) ? String(object.token) : "",
      accountId: isSet(object.accountId) ? String(object.accountId) : "",
      deviceId: isSet(object.deviceId) ? String(object.deviceId) : "",
    };
  },

  toJSON(message: RedeemInviteTokenRequest): unknown {
    const obj: any = {};
    message.token !== undefined && (obj.token = message.token);
    message.accountId !== undefined && (obj.accountId = message.accountId);
    message.deviceId !== undefined && (obj.deviceId = message.deviceId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RedeemInviteTokenRequest>, I>>(object: I): RedeemInviteTokenRequest {
    const message = createBaseRedeemInviteTokenRequest();
    message.token = object.token ?? "";
    message.accountId = object.accountId ?? "";
    message.deviceId = object.deviceId ?? "";
    return message;
  },
};

function createBaseRedeemInviteTokenResponse(): RedeemInviteTokenResponse {
  return {};
}

export const RedeemInviteTokenResponse = {
  encode(_: RedeemInviteTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RedeemInviteTokenResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedeemInviteTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RedeemInviteTokenResponse {
    return {};
  },

  toJSON(_: RedeemInviteTokenResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RedeemInviteTokenResponse>, I>>(_: I): RedeemInviteTokenResponse {
    const message = createBaseRedeemInviteTokenResponse();
    return message;
  },
};

function createBaseGetSiteInfoRequest(): GetSiteInfoRequest {
  return {};
}

export const GetSiteInfoRequest = {
  encode(_: GetSiteInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSiteInfoRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSiteInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetSiteInfoRequest {
    return {};
  },

  toJSON(_: GetSiteInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetSiteInfoRequest>, I>>(_: I): GetSiteInfoRequest {
    const message = createBaseGetSiteInfoRequest();
    return message;
  },
};

function createBaseUpdateSiteInfoRequest(): UpdateSiteInfoRequest {
  return { title: "", description: "" };
}

export const UpdateSiteInfoRequest = {
  encode(message: UpdateSiteInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSiteInfoRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSiteInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateSiteInfoRequest {
    return {
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
    };
  },

  toJSON(message: UpdateSiteInfoRequest): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateSiteInfoRequest>, I>>(object: I): UpdateSiteInfoRequest {
    const message = createBaseUpdateSiteInfoRequest();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseListMembersRequest(): ListMembersRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListMembersRequest = {
  encode(message: ListMembersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListMembersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pageSize = reader.int32();
          break;
        case 2:
          message.pageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListMembersRequest {
    return {
      pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? String(object.pageToken) : "",
    };
  },

  toJSON(message: ListMembersRequest): unknown {
    const obj: any = {};
    message.pageSize !== undefined && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== undefined && (obj.pageToken = message.pageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListMembersRequest>, I>>(object: I): ListMembersRequest {
    const message = createBaseListMembersRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListMembersResponse(): ListMembersResponse {
  return { members: [], nextPageToken: "" };
}

export const ListMembersResponse = {
  encode(message: ListMembersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.members) {
      Member.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListMembersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMembersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.members.push(Member.decode(reader, reader.uint32()));
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListMembersResponse {
    return {
      members: Array.isArray(object?.members) ? object.members.map((e: any) => Member.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListMembersResponse): unknown {
    const obj: any = {};
    if (message.members) {
      obj.members = message.members.map((e) => e ? Member.toJSON(e) : undefined);
    } else {
      obj.members = [];
    }
    message.nextPageToken !== undefined && (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListMembersResponse>, I>>(object: I): ListMembersResponse {
    const message = createBaseListMembersResponse();
    message.members = object.members?.map((e) => Member.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetMemberRequest(): GetMemberRequest {
  return { accountId: "" };
}

export const GetMemberRequest = {
  encode(message: GetMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMemberRequest {
    return { accountId: isSet(object.accountId) ? String(object.accountId) : "" };
  },

  toJSON(message: GetMemberRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = message.accountId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMemberRequest>, I>>(object: I): GetMemberRequest {
    const message = createBaseGetMemberRequest();
    message.accountId = object.accountId ?? "";
    return message;
  },
};

function createBaseDeleteMemberRequest(): DeleteMemberRequest {
  return { accountId: "" };
}

export const DeleteMemberRequest = {
  encode(message: DeleteMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteMemberRequest {
    return { accountId: isSet(object.accountId) ? String(object.accountId) : "" };
  },

  toJSON(message: DeleteMemberRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = message.accountId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteMemberRequest>, I>>(object: I): DeleteMemberRequest {
    const message = createBaseDeleteMemberRequest();
    message.accountId = object.accountId ?? "";
    return message;
  },
};

function createBaseBlockAccountRequest(): BlockAccountRequest {
  return { accountId: "" };
}

export const BlockAccountRequest = {
  encode(message: BlockAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockAccountRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BlockAccountRequest {
    return { accountId: isSet(object.accountId) ? String(object.accountId) : "" };
  },

  toJSON(message: BlockAccountRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = message.accountId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BlockAccountRequest>, I>>(object: I): BlockAccountRequest {
    const message = createBaseBlockAccountRequest();
    message.accountId = object.accountId ?? "";
    return message;
  },
};

function createBaseBlockAccountResponse(): BlockAccountResponse {
  return {};
}

export const BlockAccountResponse = {
  encode(_: BlockAccountResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockAccountResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): BlockAccountResponse {
    return {};
  },

  toJSON(_: BlockAccountResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BlockAccountResponse>, I>>(_: I): BlockAccountResponse {
    const message = createBaseBlockAccountResponse();
    return message;
  },
};

function createBaseUnblockAccountRequest(): UnblockAccountRequest {
  return { accountId: "" };
}

export const UnblockAccountRequest = {
  encode(message: UnblockAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnblockAccountRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblockAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnblockAccountRequest {
    return { accountId: isSet(object.accountId) ? String(object.accountId) : "" };
  },

  toJSON(message: UnblockAccountRequest): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = message.accountId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnblockAccountRequest>, I>>(object: I): UnblockAccountRequest {
    const message = createBaseUnblockAccountRequest();
    message.accountId = object.accountId ?? "";
    return message;
  },
};

function createBaseUnblockAccountResponse(): UnblockAccountResponse {
  return {};
}

export const UnblockAccountResponse = {
  encode(_: UnblockAccountResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnblockAccountResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblockAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UnblockAccountResponse {
    return {};
  },

  toJSON(_: UnblockAccountResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnblockAccountResponse>, I>>(_: I): UnblockAccountResponse {
    const message = createBaseUnblockAccountResponse();
    return message;
  },
};

function createBaseListBlockedAccountsRequest(): ListBlockedAccountsRequest {
  return { pageSize: 0, nextPageToken: "" };
}

export const ListBlockedAccountsRequest = {
  encode(message: ListBlockedAccountsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBlockedAccountsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlockedAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pageSize = reader.int32();
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListBlockedAccountsRequest {
    return {
      pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
      nextPageToken: isSet(object.nextPageToken) ? String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBlockedAccountsRequest): unknown {
    const obj: any = {};
    message.pageSize !== undefined && (obj.pageSize = Math.round(message.pageSize));
    message.nextPageToken !== undefined && (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListBlockedAccountsRequest>, I>>(object: I): ListBlockedAccountsRequest {
    const message = createBaseListBlockedAccountsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListBlockedAccountsResponse(): ListBlockedAccountsResponse {
  return { accounts: [], nextPageToken: "" };
}

export const ListBlockedAccountsResponse = {
  encode(message: ListBlockedAccountsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.accounts) {
      writer.uint32(10).string(v!);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBlockedAccountsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlockedAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accounts.push(reader.string());
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListBlockedAccountsResponse {
    return {
      accounts: Array.isArray(object?.accounts) ? object.accounts.map((e: any) => String(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBlockedAccountsResponse): unknown {
    const obj: any = {};
    if (message.accounts) {
      obj.accounts = message.accounts.map((e) => e);
    } else {
      obj.accounts = [];
    }
    message.nextPageToken !== undefined && (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListBlockedAccountsResponse>, I>>(object: I): ListBlockedAccountsResponse {
    const message = createBaseListBlockedAccountsResponse();
    message.accounts = object.accounts?.map((e) => e) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseInviteToken(): InviteToken {
  return { token: "", expireTime: undefined };
}

export const InviteToken = {
  encode(message: InviteToken, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InviteToken {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        case 2:
          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InviteToken {
    return {
      token: isSet(object.token) ? String(object.token) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: InviteToken): unknown {
    const obj: any = {};
    message.token !== undefined && (obj.token = message.token);
    message.expireTime !== undefined && (obj.expireTime = message.expireTime.toISOString());
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<InviteToken>, I>>(object: I): InviteToken {
    const message = createBaseInviteToken();
    message.token = object.token ?? "";
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseSiteInfo(): SiteInfo {
  return { hostname: "", title: "", description: "", owner: "" };
}

export const SiteInfo = {
  encode(message: SiteInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.owner !== "") {
      writer.uint32(34).string(message.owner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SiteInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSiteInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hostname = reader.string();
          break;
        case 2:
          message.title = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.owner = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SiteInfo {
    return {
      hostname: isSet(object.hostname) ? String(object.hostname) : "",
      title: isSet(object.title) ? String(object.title) : "",
      description: isSet(object.description) ? String(object.description) : "",
      owner: isSet(object.owner) ? String(object.owner) : "",
    };
  },

  toJSON(message: SiteInfo): unknown {
    const obj: any = {};
    message.hostname !== undefined && (obj.hostname = message.hostname);
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);
    message.owner !== undefined && (obj.owner = message.owner);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SiteInfo>, I>>(object: I): SiteInfo {
    const message = createBaseSiteInfo();
    message.hostname = object.hostname ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseMember(): Member {
  return { accountId: "", role: 0 };
}

export const Member = {
  encode(message: Member, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Member {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accountId = reader.string();
          break;
        case 2:
          message.role = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Member {
    return {
      accountId: isSet(object.accountId) ? String(object.accountId) : "",
      role: isSet(object.role) ? member_RoleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: Member): unknown {
    const obj: any = {};
    message.accountId !== undefined && (obj.accountId = message.accountId);
    message.role !== undefined && (obj.role = member_RoleToJSON(message.role));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Member>, I>>(object: I): Member {
    const message = createBaseMember();
    message.accountId = object.accountId ?? "";
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseDiscoveryConfig(): DiscoveryConfig {
  return {};
}

export const DiscoveryConfig = {
  encode(_: DiscoveryConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiscoveryConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscoveryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DiscoveryConfig {
    return {};
  },

  toJSON(_: DiscoveryConfig): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DiscoveryConfig>, I>>(_: I): DiscoveryConfig {
    const message = createBaseDiscoveryConfig();
    return message;
  },
};

/**
 * Site API service allows to configure a remote Mintter Site.
 * The server exposing this API should take care about authenticating the caller.
 */
export interface Site {
  /** Creates a new invite token for registering a new member. */
  createInviteToken(request: DeepPartial<CreateInviteTokenRequest>, metadata?: grpc.Metadata): Promise<InviteToken>;
  /** Redeem a previously created invite token to register a new member. */
  redeemInviteToken(
    request: DeepPartial<RedeemInviteTokenRequest>,
    metadata?: grpc.Metadata,
  ): Promise<RedeemInviteTokenResponse>;
  /** Gets public-facing site information. */
  getSiteInfo(request: DeepPartial<GetSiteInfoRequest>, metadata?: grpc.Metadata): Promise<SiteInfo>;
  /**
   * Updates public-facing site information. Doesn't support partial updates,
   * hence all the fields must be provided.
   */
  updateSiteInfo(request: DeepPartial<UpdateSiteInfoRequest>, metadata?: grpc.Metadata): Promise<SiteInfo>;
  /** Lists registered members on the site. */
  listMembers(request: DeepPartial<ListMembersRequest>, metadata?: grpc.Metadata): Promise<ListMembersResponse>;
  /** Gets information about a specific member. */
  getMember(request: DeepPartial<GetMemberRequest>, metadata?: grpc.Metadata): Promise<Member>;
  /** Deletes an existing member. */
  deleteMember(request: DeepPartial<DeleteMemberRequest>, metadata?: grpc.Metadata): Promise<Empty>;
  /** Blocks a given Mintter Account. */
  blockAccount(request: DeepPartial<BlockAccountRequest>, metadata?: grpc.Metadata): Promise<BlockAccountResponse>;
  /** Unblock a previously blocked Mintter Account. */
  unblockAccount(
    request: DeepPartial<UnblockAccountRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UnblockAccountResponse>;
  /** Lists currently blocked Mintter Accounts. */
  listBlockedAccounts(
    request: DeepPartial<ListBlockedAccountsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListBlockedAccountsResponse>;
}

export class SiteClientImpl implements Site {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.createInviteToken = this.createInviteToken.bind(this);
    this.redeemInviteToken = this.redeemInviteToken.bind(this);
    this.getSiteInfo = this.getSiteInfo.bind(this);
    this.updateSiteInfo = this.updateSiteInfo.bind(this);
    this.listMembers = this.listMembers.bind(this);
    this.getMember = this.getMember.bind(this);
    this.deleteMember = this.deleteMember.bind(this);
    this.blockAccount = this.blockAccount.bind(this);
    this.unblockAccount = this.unblockAccount.bind(this);
    this.listBlockedAccounts = this.listBlockedAccounts.bind(this);
  }

  createInviteToken(request: DeepPartial<CreateInviteTokenRequest>, metadata?: grpc.Metadata): Promise<InviteToken> {
    return this.rpc.unary(SiteCreateInviteTokenDesc, CreateInviteTokenRequest.fromPartial(request), metadata);
  }

  redeemInviteToken(
    request: DeepPartial<RedeemInviteTokenRequest>,
    metadata?: grpc.Metadata,
  ): Promise<RedeemInviteTokenResponse> {
    return this.rpc.unary(SiteRedeemInviteTokenDesc, RedeemInviteTokenRequest.fromPartial(request), metadata);
  }

  getSiteInfo(request: DeepPartial<GetSiteInfoRequest>, metadata?: grpc.Metadata): Promise<SiteInfo> {
    return this.rpc.unary(SiteGetSiteInfoDesc, GetSiteInfoRequest.fromPartial(request), metadata);
  }

  updateSiteInfo(request: DeepPartial<UpdateSiteInfoRequest>, metadata?: grpc.Metadata): Promise<SiteInfo> {
    return this.rpc.unary(SiteUpdateSiteInfoDesc, UpdateSiteInfoRequest.fromPartial(request), metadata);
  }

  listMembers(request: DeepPartial<ListMembersRequest>, metadata?: grpc.Metadata): Promise<ListMembersResponse> {
    return this.rpc.unary(SiteListMembersDesc, ListMembersRequest.fromPartial(request), metadata);
  }

  getMember(request: DeepPartial<GetMemberRequest>, metadata?: grpc.Metadata): Promise<Member> {
    return this.rpc.unary(SiteGetMemberDesc, GetMemberRequest.fromPartial(request), metadata);
  }

  deleteMember(request: DeepPartial<DeleteMemberRequest>, metadata?: grpc.Metadata): Promise<Empty> {
    return this.rpc.unary(SiteDeleteMemberDesc, DeleteMemberRequest.fromPartial(request), metadata);
  }

  blockAccount(request: DeepPartial<BlockAccountRequest>, metadata?: grpc.Metadata): Promise<BlockAccountResponse> {
    return this.rpc.unary(SiteBlockAccountDesc, BlockAccountRequest.fromPartial(request), metadata);
  }

  unblockAccount(
    request: DeepPartial<UnblockAccountRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UnblockAccountResponse> {
    return this.rpc.unary(SiteUnblockAccountDesc, UnblockAccountRequest.fromPartial(request), metadata);
  }

  listBlockedAccounts(
    request: DeepPartial<ListBlockedAccountsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListBlockedAccountsResponse> {
    return this.rpc.unary(SiteListBlockedAccountsDesc, ListBlockedAccountsRequest.fromPartial(request), metadata);
  }
}

export const SiteDesc = { serviceName: "com.mintter.site.v1alpha.Site" };

export const SiteCreateInviteTokenDesc: UnaryMethodDefinitionish = {
  methodName: "CreateInviteToken",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateInviteTokenRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...InviteToken.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteRedeemInviteTokenDesc: UnaryMethodDefinitionish = {
  methodName: "RedeemInviteToken",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return RedeemInviteTokenRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...RedeemInviteTokenResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteGetSiteInfoDesc: UnaryMethodDefinitionish = {
  methodName: "GetSiteInfo",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetSiteInfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...SiteInfo.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteUpdateSiteInfoDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateSiteInfo",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpdateSiteInfoRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...SiteInfo.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteListMembersDesc: UnaryMethodDefinitionish = {
  methodName: "ListMembers",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListMembersRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...ListMembersResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteGetMemberDesc: UnaryMethodDefinitionish = {
  methodName: "GetMember",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetMemberRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Member.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteDeleteMemberDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteMember",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteMemberRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Empty.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteBlockAccountDesc: UnaryMethodDefinitionish = {
  methodName: "BlockAccount",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BlockAccountRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...BlockAccountResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteUnblockAccountDesc: UnaryMethodDefinitionish = {
  methodName: "UnblockAccount",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UnblockAccountRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...UnblockAccountResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const SiteListBlockedAccountsDesc: UnaryMethodDefinitionish = {
  methodName: "ListBlockedAccounts",
  service: SiteDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListBlockedAccountsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...ListBlockedAccountsResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message);
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = date.getTime() / 1_000;
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = t.seconds * 1_000;
  millis += t.nanos / 1_000_000;
  return new Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
