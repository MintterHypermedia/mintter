// @generated by protoc-gen-es v1.2.0 with parameter "target=ts,import_extension=none"
// @generated from file documents/v1alpha/documents.proto (package com.mintter.documents.v1alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * Request to create a new draft.
 *
 * @generated from message com.mintter.documents.v1alpha.CreateDraftRequest
 */
export class CreateDraftRequest extends Message<CreateDraftRequest> {
  /**
   * Optional. Existing Document ID can be specified to update
   * previously published document. A draft will be created
   * with the content of the most recent known version.
   *
   * @generated from field: string existing_document_id = 1;
   */
  existingDocumentId = "";

  constructor(data?: PartialMessage<CreateDraftRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.CreateDraftRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "existing_document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDraftRequest {
    return new CreateDraftRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDraftRequest {
    return new CreateDraftRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDraftRequest {
    return new CreateDraftRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDraftRequest | PlainMessage<CreateDraftRequest> | undefined, b: CreateDraftRequest | PlainMessage<CreateDraftRequest> | undefined): boolean {
    return proto3.util.equals(CreateDraftRequest, a, b);
  }
}

/**
 * Request to delete an existing draft.
 *
 * @generated from message com.mintter.documents.v1alpha.DeleteDraftRequest
 */
export class DeleteDraftRequest extends Message<DeleteDraftRequest> {
  /**
   * ID of the document whose draft needs to be deleted. Only one
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  constructor(data?: PartialMessage<DeleteDraftRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.DeleteDraftRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteDraftRequest {
    return new DeleteDraftRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteDraftRequest {
    return new DeleteDraftRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteDraftRequest {
    return new DeleteDraftRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteDraftRequest | PlainMessage<DeleteDraftRequest> | undefined, b: DeleteDraftRequest | PlainMessage<DeleteDraftRequest> | undefined): boolean {
    return proto3.util.equals(DeleteDraftRequest, a, b);
  }
}

/**
 * Request to get a single draft.
 *
 * @generated from message com.mintter.documents.v1alpha.GetDraftRequest
 */
export class GetDraftRequest extends Message<GetDraftRequest> {
  /**
   * ID of the document for which draft was previously created.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  constructor(data?: PartialMessage<GetDraftRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.GetDraftRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDraftRequest {
    return new GetDraftRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDraftRequest {
    return new GetDraftRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDraftRequest {
    return new GetDraftRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDraftRequest | PlainMessage<GetDraftRequest> | undefined, b: GetDraftRequest | PlainMessage<GetDraftRequest> | undefined): boolean {
    return proto3.util.equals(GetDraftRequest, a, b);
  }
}

/**
 * Request to update an existing draft using granular operations.
 *
 * @generated from message com.mintter.documents.v1alpha.UpdateDraftRequestV2
 */
export class UpdateDraftRequestV2 extends Message<UpdateDraftRequestV2> {
  /**
   * ID of the document to be updated.
   *
   * @generated from field: string document_id = 3;
   */
  documentId = "";

  /**
   * List of document changes that must be applied to the existing document.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.DocumentChange changes = 4;
   */
  changes: DocumentChange[] = [];

  constructor(data?: PartialMessage<UpdateDraftRequestV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.UpdateDraftRequestV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "changes", kind: "message", T: DocumentChange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDraftRequestV2 {
    return new UpdateDraftRequestV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDraftRequestV2 {
    return new UpdateDraftRequestV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDraftRequestV2 {
    return new UpdateDraftRequestV2().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDraftRequestV2 | PlainMessage<UpdateDraftRequestV2> | undefined, b: UpdateDraftRequestV2 | PlainMessage<UpdateDraftRequestV2> | undefined): boolean {
    return proto3.util.equals(UpdateDraftRequestV2, a, b);
  }
}

/**
 * Granular document change.
 *
 * @generated from message com.mintter.documents.v1alpha.DocumentChange
 */
export class DocumentChange extends Message<DocumentChange> {
  /**
   * @generated from oneof com.mintter.documents.v1alpha.DocumentChange.op
   */
  op: {
    /**
     * New title to set on the document.
     *
     * @generated from field: string set_title = 1;
     */
    value: string;
    case: "setTitle";
  } | {
    /**
     * New subtitle to set on the document.
     *
     * @generated from field: string set_subtitle = 2;
     */
    value: string;
    case: "setSubtitle";
  } | {
    /**
     * Move operation that creates/moves a block within the document hierarchy.
     *
     * @generated from field: com.mintter.documents.v1alpha.DocumentChange.MoveBlock move_block = 3;
     */
    value: DocumentChange_MoveBlock;
    case: "moveBlock";
  } | {
    /**
     * New block state that replaces an existing block.
     *
     * @generated from field: com.mintter.documents.v1alpha.Block replace_block = 4;
     */
    value: Block;
    case: "replaceBlock";
  } | {
    /**
     * ID of a block to delete.
     *
     * @generated from field: string delete_block = 5;
     */
    value: string;
    case: "deleteBlock";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DocumentChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.DocumentChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "set_title", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "op" },
    { no: 2, name: "set_subtitle", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "op" },
    { no: 3, name: "move_block", kind: "message", T: DocumentChange_MoveBlock, oneof: "op" },
    { no: 4, name: "replace_block", kind: "message", T: Block, oneof: "op" },
    { no: 5, name: "delete_block", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "op" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentChange {
    return new DocumentChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentChange {
    return new DocumentChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentChange {
    return new DocumentChange().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentChange | PlainMessage<DocumentChange> | undefined, b: DocumentChange | PlainMessage<DocumentChange> | undefined): boolean {
    return proto3.util.equals(DocumentChange, a, b);
  }
}

/**
 * Operation to move an existing block to a different place in the document.
 * Move and Create operations are both expressed with this.
 * Conceptually new blocks are moved out of nowhere into the document.
 *
 * @generated from message com.mintter.documents.v1alpha.DocumentChange.MoveBlock
 */
export class DocumentChange_MoveBlock extends Message<DocumentChange_MoveBlock> {
  /**
   * ID of the block to move.
   *
   * @generated from field: string block_id = 1;
   */
  blockId = "";

  /**
   * ID of the new parent for the block being moved.
   *
   * @generated from field: string parent = 2;
   */
  parent = "";

  /**
   * ID of the new left sibling for the block being moved.
   *
   * @generated from field: string left_sibling = 3;
   */
  leftSibling = "";

  constructor(data?: PartialMessage<DocumentChange_MoveBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.DocumentChange.MoveBlock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "left_sibling", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentChange_MoveBlock {
    return new DocumentChange_MoveBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentChange_MoveBlock {
    return new DocumentChange_MoveBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentChange_MoveBlock {
    return new DocumentChange_MoveBlock().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentChange_MoveBlock | PlainMessage<DocumentChange_MoveBlock> | undefined, b: DocumentChange_MoveBlock | PlainMessage<DocumentChange_MoveBlock> | undefined): boolean {
    return proto3.util.equals(DocumentChange_MoveBlock, a, b);
  }
}

/**
 * Request to list stored drafts.
 *
 * @generated from message com.mintter.documents.v1alpha.ListDraftsRequest
 */
export class ListDraftsRequest extends Message<ListDraftsRequest> {
  /**
   * Optional. Number of results per page.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. Token for the page to return.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListDraftsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListDraftsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDraftsRequest {
    return new ListDraftsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDraftsRequest {
    return new ListDraftsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDraftsRequest {
    return new ListDraftsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDraftsRequest | PlainMessage<ListDraftsRequest> | undefined, b: ListDraftsRequest | PlainMessage<ListDraftsRequest> | undefined): boolean {
    return proto3.util.equals(ListDraftsRequest, a, b);
  }
}

/**
 * Response for listing drafts.
 *
 * @generated from message com.mintter.documents.v1alpha.ListDraftsResponse
 */
export class ListDraftsResponse extends Message<ListDraftsResponse> {
  /**
   * Drafts matching the list request.
   * Content is omitted.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.Document documents = 1;
   */
  documents: Document[] = [];

  /**
   * Token for the next page if there's any.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListDraftsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListDraftsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "documents", kind: "message", T: Document, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDraftsResponse {
    return new ListDraftsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDraftsResponse {
    return new ListDraftsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDraftsResponse {
    return new ListDraftsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDraftsResponse | PlainMessage<ListDraftsResponse> | undefined, b: ListDraftsResponse | PlainMessage<ListDraftsResponse> | undefined): boolean {
    return proto3.util.equals(ListDraftsResponse, a, b);
  }
}

/**
 * Request to publish a draft.
 *
 * @generated from message com.mintter.documents.v1alpha.PublishDraftRequest
 */
export class PublishDraftRequest extends Message<PublishDraftRequest> {
  /**
   * ID of the document which current draft needs to be published.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  constructor(data?: PartialMessage<PublishDraftRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.PublishDraftRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishDraftRequest {
    return new PublishDraftRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishDraftRequest {
    return new PublishDraftRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishDraftRequest {
    return new PublishDraftRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PublishDraftRequest | PlainMessage<PublishDraftRequest> | undefined, b: PublishDraftRequest | PlainMessage<PublishDraftRequest> | undefined): boolean {
    return proto3.util.equals(PublishDraftRequest, a, b);
  }
}

/**
 * Request for getting a single publication.
 *
 * @generated from message com.mintter.documents.v1alpha.GetPublicationRequest
 */
export class GetPublicationRequest extends Message<GetPublicationRequest> {
  /**
   * Required. ID of the published document.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  /**
   * Optional. Specific version of the published document. If empty, the latest one is returned.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Optional. If true, only local publications will be found. False by default.
   *
   * @generated from field: bool local_only = 3;
   */
  localOnly = false;

  constructor(data?: PartialMessage<GetPublicationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.GetPublicationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "local_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPublicationRequest {
    return new GetPublicationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPublicationRequest {
    return new GetPublicationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPublicationRequest {
    return new GetPublicationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPublicationRequest | PlainMessage<GetPublicationRequest> | undefined, b: GetPublicationRequest | PlainMessage<GetPublicationRequest> | undefined): boolean {
    return proto3.util.equals(GetPublicationRequest, a, b);
  }
}

/**
 * Request for deleting a publication.
 *
 * @generated from message com.mintter.documents.v1alpha.DeletePublicationRequest
 */
export class DeletePublicationRequest extends Message<DeletePublicationRequest> {
  /**
   * Document ID of the publication to be removed.
   * All versions will also be removed.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  constructor(data?: PartialMessage<DeletePublicationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.DeletePublicationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePublicationRequest {
    return new DeletePublicationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePublicationRequest {
    return new DeletePublicationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePublicationRequest {
    return new DeletePublicationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeletePublicationRequest | PlainMessage<DeletePublicationRequest> | undefined, b: DeletePublicationRequest | PlainMessage<DeletePublicationRequest> | undefined): boolean {
    return proto3.util.equals(DeletePublicationRequest, a, b);
  }
}

/**
 * Request for listing publications.
 *
 * @generated from message com.mintter.documents.v1alpha.ListPublicationsRequest
 */
export class ListPublicationsRequest extends Message<ListPublicationsRequest> {
  /**
   * Optional. Number of results per page. Default is defined by the server.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. Value from next_page_token obtains from a previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListPublicationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListPublicationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPublicationsRequest {
    return new ListPublicationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPublicationsRequest {
    return new ListPublicationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPublicationsRequest {
    return new ListPublicationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListPublicationsRequest | PlainMessage<ListPublicationsRequest> | undefined, b: ListPublicationsRequest | PlainMessage<ListPublicationsRequest> | undefined): boolean {
    return proto3.util.equals(ListPublicationsRequest, a, b);
  }
}

/**
 * Response with list of publications.
 *
 * @generated from message com.mintter.documents.v1alpha.ListPublicationsResponse
 */
export class ListPublicationsResponse extends Message<ListPublicationsResponse> {
  /**
   * List of publications matching the request.
   * Only most recent versions are returned.
   * Content is omitted, only metadata is present.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.Publication publications = 1;
   */
  publications: Publication[] = [];

  /**
   * Token for the next page if there're more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListPublicationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListPublicationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "publications", kind: "message", T: Publication, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPublicationsResponse {
    return new ListPublicationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPublicationsResponse {
    return new ListPublicationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPublicationsResponse {
    return new ListPublicationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListPublicationsResponse | PlainMessage<ListPublicationsResponse> | undefined, b: ListPublicationsResponse | PlainMessage<ListPublicationsResponse> | undefined): boolean {
    return proto3.util.equals(ListPublicationsResponse, a, b);
  }
}

/**
 * Request to know how many accounts have authored a document.
 *
 * @generated from message com.mintter.documents.v1alpha.ListAuthorsRequest
 */
export class ListAuthorsRequest extends Message<ListAuthorsRequest> {
  /**
   * Required. Document ID.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  /**
   * Required. The version of the document.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Algorithm to use for getting attributions.
   *
   * @generated from field: com.mintter.documents.v1alpha.ListAuthorsRequest.PercentageAlgo algo = 3;
   */
  algo = ListAuthorsRequest_PercentageAlgo.NAIVE;

  constructor(data?: PartialMessage<ListAuthorsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListAuthorsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "algo", kind: "enum", T: proto3.getEnumType(ListAuthorsRequest_PercentageAlgo) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAuthorsRequest {
    return new ListAuthorsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAuthorsRequest {
    return new ListAuthorsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAuthorsRequest {
    return new ListAuthorsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAuthorsRequest | PlainMessage<ListAuthorsRequest> | undefined, b: ListAuthorsRequest | PlainMessage<ListAuthorsRequest> | undefined): boolean {
    return proto3.util.equals(ListAuthorsRequest, a, b);
  }
}

/**
 * Algorithm used to calculate percentages.
 *
 * @generated from enum com.mintter.documents.v1alpha.ListAuthorsRequest.PercentageAlgo
 */
export enum ListAuthorsRequest_PercentageAlgo {
  /**
   * Equal-weight. each author receives 1/len(authors) of the pie.
   *
   * @generated from enum value: NAIVE = 0;
   */
  NAIVE = 0,

  /**
   * Since each block has an author in version <version>, percentages
   * are calculated by dividing the number of blocks authored by 
   * a given account by the total number of blocks in the document.
   *
   * @generated from enum value: BLOCKCOUNT = 1;
   */
  BLOCKCOUNT = 1,

  /**
   * Since we can know how many changes a single block had (up to version
   * <version>, we can count changes made per author divided by the total
   * amount of changes in all blocks.
   *
   * @generated from enum value: BLOCKCHANGES = 2;
   */
  BLOCKCHANGES = 2,

  /**
   * Count how many words can be attributed to an author divided by the
   * the total word count of the document.
   *
   * @generated from enum value: WORDCOUNT = 3;
   */
  WORDCOUNT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ListAuthorsRequest_PercentageAlgo)
proto3.util.setEnumType(ListAuthorsRequest_PercentageAlgo, "com.mintter.documents.v1alpha.ListAuthorsRequest.PercentageAlgo", [
  { no: 0, name: "NAIVE" },
  { no: 1, name: "BLOCKCOUNT" },
  { no: 2, name: "BLOCKCHANGES" },
  { no: 3, name: "WORDCOUNT" },
]);

/**
 * @generated from message com.mintter.documents.v1alpha.ListAuthorsResponse
 */
export class ListAuthorsResponse extends Message<ListAuthorsResponse> {
  /**
   * @generated from field: repeated com.mintter.documents.v1alpha.Slice authors = 1;
   */
  authors: Slice[] = [];

  constructor(data?: PartialMessage<ListAuthorsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.ListAuthorsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authors", kind: "message", T: Slice, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAuthorsResponse {
    return new ListAuthorsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAuthorsResponse {
    return new ListAuthorsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAuthorsResponse {
    return new ListAuthorsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAuthorsResponse | PlainMessage<ListAuthorsResponse> | undefined, b: ListAuthorsResponse | PlainMessage<ListAuthorsResponse> | undefined): boolean {
    return proto3.util.equals(ListAuthorsResponse, a, b);
  }
}

/**
 * State of the document after publication.
 *
 * @generated from message com.mintter.documents.v1alpha.Publication
 */
export class Publication extends Message<Publication> {
  /**
   * Version points to the state of the publication at some point in time.
   * It is represented as a string, although it can be a list of CIDs.
   * The order of hashes must be deterministic, which is tricky because
   * CIDs can have different base encoding when represented as a string.
   * So same hash, can have different string representations.
   * We should either define a canonical base encoding, or sort binary
   * representation of the hash portion of the CID.
   * Anyway, all these details should be opaque for consumers of this API.
   * On the other hand, if API consumers never compare versions as plain strings
   * it doesn't really matter if different version strings point to the same document.
   *
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * Published document.
   *
   * @generated from field: com.mintter.documents.v1alpha.Document document = 2;
   */
  document?: Document;

  constructor(data?: PartialMessage<Publication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.Publication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "document", kind: "message", T: Document },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Publication {
    return new Publication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Publication {
    return new Publication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Publication {
    return new Publication().fromJsonString(jsonString, options);
  }

  static equals(a: Publication | PlainMessage<Publication> | undefined, b: Publication | PlainMessage<Publication> | undefined): boolean {
    return proto3.util.equals(Publication, a, b);
  }
}

/**
 * Document represents metadata and content of a draft or publication.
 *
 * @generated from message com.mintter.documents.v1alpha.Document
 */
export class Document extends Message<Document> {
  /**
   * Permanent ID of the document.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Title of the document.
   *
   * @generated from field: string title = 2;
   */
  title = "";

  /**
   * Subtitle of the document.
   *
   * @generated from field: string subtitle = 3;
   */
  subtitle = "";

  /**
   * Output only. DeviceID that created the document.
   *
   * @generated from field: string creator = 4;
   */
  creator = "";

  /**
   * This is WIP feature for block-aware API. It will supersede the `content` field.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.BlockNode children = 9;
   */
  children: BlockNode[] = [];

  /**
   * Output only. Time when document was created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 6;
   */
  createTime?: Timestamp;

  /**
   * Output only. Time when document was updated.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 7;
   */
  updateTime?: Timestamp;

  /**
   * Output only. Time when this version was published. Not present in drafts.
   *
   * @generated from field: google.protobuf.Timestamp publish_time = 8;
   */
  publishTime?: Timestamp;

  constructor(data?: PartialMessage<Document>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.Document";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subtitle", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "children", kind: "message", T: BlockNode, repeated: true },
    { no: 6, name: "create_time", kind: "message", T: Timestamp },
    { no: 7, name: "update_time", kind: "message", T: Timestamp },
    { no: 8, name: "publish_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Document {
    return new Document().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Document {
    return new Document().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Document {
    return new Document().fromJsonString(jsonString, options);
  }

  static equals(a: Document | PlainMessage<Document> | undefined, b: Document | PlainMessage<Document> | undefined): boolean {
    return proto3.util.equals(Document, a, b);
  }
}

/**
 * Content block with children.
 *
 * @generated from message com.mintter.documents.v1alpha.BlockNode
 */
export class BlockNode extends Message<BlockNode> {
  /**
   * Content block.
   *
   * @generated from field: com.mintter.documents.v1alpha.Block block = 1;
   */
  block?: Block;

  /**
   * Child blocks.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.BlockNode children = 2;
   */
  children: BlockNode[] = [];

  constructor(data?: PartialMessage<BlockNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.BlockNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block", kind: "message", T: Block },
    { no: 2, name: "children", kind: "message", T: BlockNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockNode {
    return new BlockNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockNode {
    return new BlockNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockNode {
    return new BlockNode().fromJsonString(jsonString, options);
  }

  static equals(a: BlockNode | PlainMessage<BlockNode> | undefined, b: BlockNode | PlainMessage<BlockNode> | undefined): boolean {
    return proto3.util.equals(BlockNode, a, b);
  }
}

/**
 * Content block.
 *
 * @generated from message com.mintter.documents.v1alpha.Block
 */
export class Block extends Message<Block> {
  /**
   * Block ID. Must be unique within the document.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Type of the block. Specific to the renderer.
   *
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * Text of the content block.
   *
   * @generated from field: string text = 3;
   */
  text = "";

  /**
   * Arbitrary attributes of the block.
   *
   * @generated from field: map<string, string> attributes = 4;
   */
  attributes: { [key: string]: string } = {};

  /**
   * Annotation "layers" of the block.
   *
   * @generated from field: repeated com.mintter.documents.v1alpha.Annotation annotations = 5;
   */
  annotations: Annotation[] = [];

  /**
   * Output only. Current revision of the block. It's the ID of the last Change that modified this block.
   * Additional information about the Change can be obtained using the Changes service.
   *
   * @generated from field: string revision = 6;
   */
  revision = "";

  constructor(data?: PartialMessage<Block>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.Block";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "annotations", kind: "message", T: Annotation, repeated: true },
    { no: 6, name: "revision", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Block {
    return new Block().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJsonString(jsonString, options);
  }

  static equals(a: Block | PlainMessage<Block> | undefined, b: Block | PlainMessage<Block> | undefined): boolean {
    return proto3.util.equals(Block, a, b);
  }
}

/**
 * Conceptual annotation "layer" that is applied to arbitrary spans of block text.
 * An "identity" of the layer should be derived deterministically based on its type
 * attributes. Spans inside the same annotation can't overlap.
 *
 * Spans are stored inside the Annotation in a "columnar" format,
 * i.e. StructureOfArrays instead of ArrayOfStructures. See: https://en.wikipedia.org/wiki/AoS_and_SoA.
 * This is useful to reduce the number of allocations and offers more compact serialization, because
 * protobuf is able to "pack" primitive repeated fields more efficiently.
 *
 * @generated from message com.mintter.documents.v1alpha.Annotation
 */
export class Annotation extends Message<Annotation> {
  /**
   * Type of the annotation.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * Arbitrary key-value attributes of the annotation.
   *
   * @generated from field: map<string, string> attributes = 2;
   */
  attributes: { [key: string]: string } = {};

  /**
   * Start offsets of possibly disjoint spans of text for which this annotation is applied.
   * Must be sorted and have the same number of items as `ends` list.
   *
   * @generated from field: repeated int32 starts = 3;
   */
  starts: number[] = [];

  /**
   * End offsets of possibly disjoint spans of text for which this annotation is applied.
   * Must be sorted and have the same number of items as `starts` list.
   *
   * @generated from field: repeated int32 ends = 4;
   */
  ends: number[] = [];

  constructor(data?: PartialMessage<Annotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.Annotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "starts", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 4, name: "ends", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Annotation {
    return new Annotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Annotation {
    return new Annotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Annotation {
    return new Annotation().fromJsonString(jsonString, options);
  }

  static equals(a: Annotation | PlainMessage<Annotation> | undefined, b: Annotation | PlainMessage<Annotation> | undefined): boolean {
    return proto3.util.equals(Annotation, a, b);
  }
}

/**
 * Given a publication, each author contributes to that document in 
 * greater or lesser manner quantified by the size of this Slice.
 *
 * @generated from message com.mintter.documents.v1alpha.Slice
 */
export class Slice extends Message<Slice> {
  /**
   * Account CID 
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * Percentage 0-1 of authorship based on the selected algorithm.
   *
   * @generated from field: float percentage = 2;
   */
  percentage = 0;

  constructor(data?: PartialMessage<Slice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.documents.v1alpha.Slice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "percentage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Slice {
    return new Slice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Slice {
    return new Slice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Slice {
    return new Slice().fromJsonString(jsonString, options);
  }

  static equals(a: Slice | PlainMessage<Slice> | undefined, b: Slice | PlainMessage<Slice> | undefined): boolean {
    return proto3.util.equals(Slice, a, b);
  }
}

