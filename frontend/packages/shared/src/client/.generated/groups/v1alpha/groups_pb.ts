// @generated by protoc-gen-es v1.3.1 with parameter "target=ts,import_extension=none"
// @generated from file groups/v1alpha/groups.proto (package com.mintter.groups.v1alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * Role of a group member.
 *
 * @generated from enum com.mintter.groups.v1alpha.Role
 */
export enum Role {
  /**
   * Zero value which is an invalid role. This role is used to delete members,
   * and serves as a tombstone, because in our CRDT there's no way to truly delete something.
   *
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  ROLE_UNSPECIFIED = 0,

  /**
   * Output only. Role for an owner. Cannot be used in updates, can only be returned in queries.
   *
   * @generated from enum value: OWNER = 1;
   */
  OWNER = 1,

  /**
   * Editor role which allows members to manage content of the group.
   *
   * @generated from enum value: EDITOR = 2;
   */
  EDITOR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Role)
proto3.util.setEnumType(Role, "com.mintter.groups.v1alpha.Role", [
  { no: 0, name: "ROLE_UNSPECIFIED" },
  { no: 1, name: "OWNER" },
  { no: 2, name: "EDITOR" },
]);

/**
 * Request to create a group.
 *
 * @generated from message com.mintter.groups.v1alpha.CreateGroupRequest
 */
export class CreateGroupRequest extends Message<CreateGroupRequest> {
  /**
   * Required. Title of the new group.
   *
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * Optional. Description of the new group.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Optional. List of initial members for the new group.
   * Members can also be managed with separate requests after group is already created.
   *
   * @generated from field: map<string, com.mintter.groups.v1alpha.Role> members = 3;
   */
  members: { [key: string]: Role } = {};

  constructor(data?: PartialMessage<CreateGroupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.CreateGroupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "members", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(Role)} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateGroupRequest {
    return new CreateGroupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateGroupRequest {
    return new CreateGroupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateGroupRequest {
    return new CreateGroupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateGroupRequest | PlainMessage<CreateGroupRequest> | undefined, b: CreateGroupRequest | PlainMessage<CreateGroupRequest> | undefined): boolean {
    return proto3.util.equals(CreateGroupRequest, a, b);
  }
}

/**
 * Request to get a group.
 *
 * @generated from message com.mintter.groups.v1alpha.GetGroupRequest
 */
export class GetGroupRequest extends Message<GetGroupRequest> {
  /**
   * Required. ID of the group to get.
   * Must be a fully-qualified EID.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. Version of the group to get information about.
   * If empty, latest_version is assumed.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<GetGroupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.GetGroupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetGroupRequest {
    return new GetGroupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetGroupRequest {
    return new GetGroupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetGroupRequest {
    return new GetGroupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetGroupRequest | PlainMessage<GetGroupRequest> | undefined, b: GetGroupRequest | PlainMessage<GetGroupRequest> | undefined): boolean {
    return proto3.util.equals(GetGroupRequest, a, b);
  }
}

/**
 * Request to update a group.
 * Some fields are required, even if unchanged,
 * to distinguish between setting the value to an empty string, from an unchanged value.
 * Read the comments!
 *
 * @generated from message com.mintter.groups.v1alpha.UpdateGroupRequest
 */
export class UpdateGroupRequest extends Message<UpdateGroupRequest> {
  /**
   * ID of the group to update.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. Title of the Group.
   * Can be omitted if unchanged.
   *
   * @generated from field: string title = 2;
   */
  title = "";

  /**
   * Required. Description of the Group. Can be empty string.
   * Must always be provided, even if unchanged
   * to distinguish unchanged value from setting to empty string.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Optional. List of members to be updated in the Group.
   * Key is the member's Account ID,
   * value is the Role.
   * To remove a member from the group, set the role to unspecified.
   * Only updated records have to be sent, not all the members of the group.
   *
   * @generated from field: map<string, com.mintter.groups.v1alpha.Role> updated_members = 4;
   */
  updatedMembers: { [key: string]: Role } = {};

  /**
   * Optional. List of content to be updated in the Group.
   * Key is a pretty path on which the content is published,
   * value is a Hyperdocs URL of the content.
   * To unpublish content set the value to an empty string for a given pretty path.
   * Only updated records have to be sent, not all the content of the group.
   *
   * @generated from field: map<string, string> updated_content = 5;
   */
  updatedContent: { [key: string]: string } = {};

  constructor(data?: PartialMessage<UpdateGroupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.UpdateGroupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "updated_members", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(Role)} },
    { no: 5, name: "updated_content", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateGroupRequest {
    return new UpdateGroupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateGroupRequest {
    return new UpdateGroupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateGroupRequest {
    return new UpdateGroupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateGroupRequest | PlainMessage<UpdateGroupRequest> | undefined, b: UpdateGroupRequest | PlainMessage<UpdateGroupRequest> | undefined): boolean {
    return proto3.util.equals(UpdateGroupRequest, a, b);
  }
}

/**
 * Request to list members.
 *
 * @generated from message com.mintter.groups.v1alpha.ListMembersRequest
 */
export class ListMembersRequest extends Message<ListMembersRequest> {
  /**
   * Required. ID of the group to list members of.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. Version of the group to list members of.
   * If not specified, the latest version of the group
   * according to its members is used.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Optional. Maximum number of members to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing members from.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListMembersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListMembersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListMembersRequest | PlainMessage<ListMembersRequest> | undefined, b: ListMembersRequest | PlainMessage<ListMembersRequest> | undefined): boolean {
    return proto3.util.equals(ListMembersRequest, a, b);
  }
}

/**
 * Response to list members.
 *
 * @generated from message com.mintter.groups.v1alpha.ListMembersResponse
 */
export class ListMembersResponse extends Message<ListMembersResponse> {
  /**
   * ID of the group owner.
   *
   * @generated from field: string owner_account_id = 1;
   */
  ownerAccountId = "";

  /**
   * List of members of the group, including the owner.
   *
   * @generated from field: map<string, com.mintter.groups.v1alpha.Role> members = 2;
   */
  members: { [key: string]: Role } = {};

  /**
   * Token to continue listing members from.
   *
   * @generated from field: string next_page_token = 3;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListMembersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListMembersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "members", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(Role)} },
    { no: 3, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListMembersResponse | PlainMessage<ListMembersResponse> | undefined, b: ListMembersResponse | PlainMessage<ListMembersResponse> | undefined): boolean {
    return proto3.util.equals(ListMembersResponse, a, b);
  }
}

/**
 * Request to list content.
 *
 * @generated from message com.mintter.groups.v1alpha.ListContentRequest
 */
export class ListContentRequest extends Message<ListContentRequest> {
  /**
   * Required. ID of the group to list content of.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. Version of the group to list content of.
   * If not specified, the latest version of the group
   * according to its members is used.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Optional. Maximum number of content to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing content from.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListContentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListContentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListContentRequest {
    return new ListContentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListContentRequest {
    return new ListContentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListContentRequest {
    return new ListContentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListContentRequest | PlainMessage<ListContentRequest> | undefined, b: ListContentRequest | PlainMessage<ListContentRequest> | undefined): boolean {
    return proto3.util.equals(ListContentRequest, a, b);
  }
}

/**
 * Response to list content.
 *
 * @generated from message com.mintter.groups.v1alpha.ListContentResponse
 */
export class ListContentResponse extends Message<ListContentResponse> {
  /**
   * List of content of the group.
   * Key is the path and value is a Hyperdocs URL to the content.
   *
   * @generated from field: map<string, string> content = 1;
   */
  content: { [key: string]: string } = {};

  /**
   * Token to continue listing content from.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListContentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListContentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListContentResponse {
    return new ListContentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListContentResponse {
    return new ListContentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListContentResponse {
    return new ListContentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListContentResponse | PlainMessage<ListContentResponse> | undefined, b: ListContentResponse | PlainMessage<ListContentResponse> | undefined): boolean {
    return proto3.util.equals(ListContentResponse, a, b);
  }
}

/**
 * Request to list groups.
 *
 * @generated from message com.mintter.groups.v1alpha.ListGroupsRequest
 */
export class ListGroupsRequest extends Message<ListGroupsRequest> {
  /**
   * Optional. Maximum number of groups to return.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing groups from.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListGroupsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListGroupsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListGroupsRequest {
    return new ListGroupsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListGroupsRequest {
    return new ListGroupsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListGroupsRequest {
    return new ListGroupsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListGroupsRequest | PlainMessage<ListGroupsRequest> | undefined, b: ListGroupsRequest | PlainMessage<ListGroupsRequest> | undefined): boolean {
    return proto3.util.equals(ListGroupsRequest, a, b);
  }
}

/**
 * Response to list groups.
 *
 * @generated from message com.mintter.groups.v1alpha.ListGroupsResponse
 */
export class ListGroupsResponse extends Message<ListGroupsResponse> {
  /**
   * List of groups.
   *
   * @generated from field: repeated com.mintter.groups.v1alpha.Group groups = 1;
   */
  groups: Group[] = [];

  /**
   * Token to continue listing groups from.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListGroupsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListGroupsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groups", kind: "message", T: Group, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListGroupsResponse {
    return new ListGroupsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListGroupsResponse {
    return new ListGroupsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListGroupsResponse {
    return new ListGroupsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListGroupsResponse | PlainMessage<ListGroupsResponse> | undefined, b: ListGroupsResponse | PlainMessage<ListGroupsResponse> | undefined): boolean {
    return proto3.util.equals(ListGroupsResponse, a, b);
  }
}

/**
 * Makes a site out of an existing group.
 *
 * @generated from message com.mintter.groups.v1alpha.ConvertToSiteRequest
 */
export class ConvertToSiteRequest extends Message<ConvertToSiteRequest> {
  /**
   * Required. Secret link provided by the site deployment script.
   *
   * @generated from field: string link = 1;
   */
  link = "";

  /**
   * Required. Group ID to convert to a site
   *
   * @generated from field: string group_id = 2;
   */
  groupId = "";

  /**
   * Optional. Version of the group to be converted. Latest
   * version if not provided
   *
   * @generated from field: string version = 3;
   */
  version = "";

  constructor(data?: PartialMessage<ConvertToSiteRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ConvertToSiteRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "group_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConvertToSiteRequest {
    return new ConvertToSiteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConvertToSiteRequest {
    return new ConvertToSiteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConvertToSiteRequest {
    return new ConvertToSiteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ConvertToSiteRequest | PlainMessage<ConvertToSiteRequest> | undefined, b: ConvertToSiteRequest | PlainMessage<ConvertToSiteRequest> | undefined): boolean {
    return proto3.util.equals(ConvertToSiteRequest, a, b);
  }
}

/**
 * Response to convert to site.
 *
 * @generated from message com.mintter.groups.v1alpha.ConvertToSiteResponse
 */
export class ConvertToSiteResponse extends Message<ConvertToSiteResponse> {
  /**
   * Account of the sites owner.
   *
   * @generated from field: string owner_id = 1;
   */
  ownerId = "";

  /**
   * Hostname of the site.
   *
   * @generated from field: string hostname = 2;
   */
  hostname = "";

  constructor(data?: PartialMessage<ConvertToSiteResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ConvertToSiteResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConvertToSiteResponse {
    return new ConvertToSiteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConvertToSiteResponse {
    return new ConvertToSiteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConvertToSiteResponse {
    return new ConvertToSiteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ConvertToSiteResponse | PlainMessage<ConvertToSiteResponse> | undefined, b: ConvertToSiteResponse | PlainMessage<ConvertToSiteResponse> | undefined): boolean {
    return proto3.util.equals(ConvertToSiteResponse, a, b);
  }
}

/**
 * Request to get site info.
 *
 * @generated from message com.mintter.groups.v1alpha.GetSiteInfoRequest
 */
export class GetSiteInfoRequest extends Message<GetSiteInfoRequest> {
  /**
   * Required. hostname where the site is published.
   *
   * @generated from field: string hostname = 1;
   */
  hostname = "";

  /**
   * Optional. Maximum number of members to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing members from.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<GetSiteInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.GetSiteInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSiteInfoRequest {
    return new GetSiteInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSiteInfoRequest {
    return new GetSiteInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSiteInfoRequest {
    return new GetSiteInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSiteInfoRequest | PlainMessage<GetSiteInfoRequest> | undefined, b: GetSiteInfoRequest | PlainMessage<GetSiteInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetSiteInfoRequest, a, b);
  }
}

/**
 * Response to get site info.
 *
 * @generated from message com.mintter.groups.v1alpha.GetSiteInfoResponse
 */
export class GetSiteInfoResponse extends Message<GetSiteInfoResponse> {
  /**
   * ID of the group the site is serving.
   *
   * @generated from field: string group_id = 1;
   */
  groupId = "";

  /**
   * Current Version of the group that the site is serving.
   * Empty means last version.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Owner's account of the site.
   *
   * @generated from field: string owner_id = 3;
   */
  ownerId = "";

  constructor(data?: PartialMessage<GetSiteInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.GetSiteInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "owner_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSiteInfoResponse {
    return new GetSiteInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSiteInfoResponse {
    return new GetSiteInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSiteInfoResponse {
    return new GetSiteInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSiteInfoResponse | PlainMessage<GetSiteInfoResponse> | undefined, b: GetSiteInfoResponse | PlainMessage<GetSiteInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetSiteInfoResponse, a, b);
  }
}

/**
 * Request to list groups for a document.
 *
 * @generated from message com.mintter.groups.v1alpha.ListDocumentGroupsRequest
 */
export class ListDocumentGroupsRequest extends Message<ListDocumentGroupsRequest> {
  /**
   * Required. ID of the document to list groups for.
   * Must be fully-qualified Entity ID.
   *
   * @generated from field: string document_id = 1;
   */
  documentId = "";

  /**
   * Optional. Maximum number of groups to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing groups from.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListDocumentGroupsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListDocumentGroupsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDocumentGroupsRequest {
    return new ListDocumentGroupsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDocumentGroupsRequest {
    return new ListDocumentGroupsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDocumentGroupsRequest {
    return new ListDocumentGroupsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDocumentGroupsRequest | PlainMessage<ListDocumentGroupsRequest> | undefined, b: ListDocumentGroupsRequest | PlainMessage<ListDocumentGroupsRequest> | undefined): boolean {
    return proto3.util.equals(ListDocumentGroupsRequest, a, b);
  }
}

/**
 * Response to list groups for a document.
 *
 * @generated from message com.mintter.groups.v1alpha.ListDocumentGroupsResponse
 */
export class ListDocumentGroupsResponse extends Message<ListDocumentGroupsResponse> {
  /**
   * List of document publications in groups.
   *
   * @generated from field: repeated com.mintter.groups.v1alpha.ListDocumentGroupsResponse.Item items = 1;
   */
  items: ListDocumentGroupsResponse_Item[] = [];

  /**
   * Token to continue listing groups from.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListDocumentGroupsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListDocumentGroupsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: ListDocumentGroupsResponse_Item, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDocumentGroupsResponse {
    return new ListDocumentGroupsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDocumentGroupsResponse {
    return new ListDocumentGroupsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDocumentGroupsResponse {
    return new ListDocumentGroupsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDocumentGroupsResponse | PlainMessage<ListDocumentGroupsResponse> | undefined, b: ListDocumentGroupsResponse | PlainMessage<ListDocumentGroupsResponse> | undefined): boolean {
    return proto3.util.equals(ListDocumentGroupsResponse, a, b);
  }
}

/**
 * @generated from message com.mintter.groups.v1alpha.ListDocumentGroupsResponse.Item
 */
export class ListDocumentGroupsResponse_Item extends Message<ListDocumentGroupsResponse_Item> {
  /**
   * ID of the group that the document is published to.
   *
   * @generated from field: string group_id = 1;
   */
  groupId = "";

  /**
   * ID of the group change that published the document to the group.
   *
   * @generated from field: string group_change = 2;
   */
  groupChange = "";

  /**
   * Timestamp of the change that published the document to the group.
   *
   * @generated from field: google.protobuf.Timestamp change_time = 3;
   */
  changeTime?: Timestamp;

  /**
   * Path at which document is published.
   *
   * @generated from field: string path = 4;
   */
  path = "";

  /**
   * Raw URL that is published to the group.
   *
   * @generated from field: string raw_url = 5;
   */
  rawUrl = "";

  constructor(data?: PartialMessage<ListDocumentGroupsResponse_Item>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListDocumentGroupsResponse.Item";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "group_change", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "change_time", kind: "message", T: Timestamp },
    { no: 4, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "raw_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDocumentGroupsResponse_Item {
    return new ListDocumentGroupsResponse_Item().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDocumentGroupsResponse_Item {
    return new ListDocumentGroupsResponse_Item().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDocumentGroupsResponse_Item {
    return new ListDocumentGroupsResponse_Item().fromJsonString(jsonString, options);
  }

  static equals(a: ListDocumentGroupsResponse_Item | PlainMessage<ListDocumentGroupsResponse_Item> | undefined, b: ListDocumentGroupsResponse_Item | PlainMessage<ListDocumentGroupsResponse_Item> | undefined): boolean {
    return proto3.util.equals(ListDocumentGroupsResponse_Item, a, b);
  }
}

/**
 * Request to list groups for an account.
 *
 * @generated from message com.mintter.groups.v1alpha.ListAccountGroupsRequest
 */
export class ListAccountGroupsRequest extends Message<ListAccountGroupsRequest> {
  /**
   * Required. ID of the account to list groups for.
   * Must be Account ID, not the ID of the Account Entity.
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * Optional. Maximum number of groups to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing groups from.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListAccountGroupsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListAccountGroupsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccountGroupsRequest {
    return new ListAccountGroupsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccountGroupsRequest {
    return new ListAccountGroupsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccountGroupsRequest {
    return new ListAccountGroupsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccountGroupsRequest | PlainMessage<ListAccountGroupsRequest> | undefined, b: ListAccountGroupsRequest | PlainMessage<ListAccountGroupsRequest> | undefined): boolean {
    return proto3.util.equals(ListAccountGroupsRequest, a, b);
  }
}

/**
 * Response to list groups for an account.
 *
 * @generated from message com.mintter.groups.v1alpha.ListAccountGroupsResponse
 */
export class ListAccountGroupsResponse extends Message<ListAccountGroupsResponse> {
  /**
   * List of groups that the account is a member of with their role.
   *
   * @generated from field: repeated com.mintter.groups.v1alpha.ListAccountGroupsResponse.Item items = 1;
   */
  items: ListAccountGroupsResponse_Item[] = [];

  /**
   * Token to continue listing groups from.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListAccountGroupsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListAccountGroupsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: ListAccountGroupsResponse_Item, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccountGroupsResponse {
    return new ListAccountGroupsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccountGroupsResponse {
    return new ListAccountGroupsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccountGroupsResponse {
    return new ListAccountGroupsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccountGroupsResponse | PlainMessage<ListAccountGroupsResponse> | undefined, b: ListAccountGroupsResponse | PlainMessage<ListAccountGroupsResponse> | undefined): boolean {
    return proto3.util.equals(ListAccountGroupsResponse, a, b);
  }
}

/**
 * @generated from message com.mintter.groups.v1alpha.ListAccountGroupsResponse.Item
 */
export class ListAccountGroupsResponse_Item extends Message<ListAccountGroupsResponse_Item> {
  /**
   * @generated from field: com.mintter.groups.v1alpha.Group group = 1;
   */
  group?: Group;

  /**
   * @generated from field: com.mintter.groups.v1alpha.Role role = 2;
   */
  role = Role.ROLE_UNSPECIFIED;

  constructor(data?: PartialMessage<ListAccountGroupsResponse_Item>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListAccountGroupsResponse.Item";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group", kind: "message", T: Group },
    { no: 2, name: "role", kind: "enum", T: proto3.getEnumType(Role) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccountGroupsResponse_Item {
    return new ListAccountGroupsResponse_Item().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccountGroupsResponse_Item {
    return new ListAccountGroupsResponse_Item().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccountGroupsResponse_Item {
    return new ListAccountGroupsResponse_Item().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccountGroupsResponse_Item | PlainMessage<ListAccountGroupsResponse_Item> | undefined, b: ListAccountGroupsResponse_Item | PlainMessage<ListAccountGroupsResponse_Item> | undefined): boolean {
    return proto3.util.equals(ListAccountGroupsResponse_Item, a, b);
  }
}

/**
 * Group represents the basic information about a group entity.
 *
 * @generated from message com.mintter.groups.v1alpha.Group
 */
export class Group extends Message<Group> {
  /**
   * ID of the group.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Title of the group.
   *
   * @generated from field: string title = 2;
   */
  title = "";

  /**
   * Description of the group.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Account ID of the group owner.
   *
   * @generated from field: string owner_account_id = 4;
   */
  ownerAccountId = "";

  /**
   * Timestamp when the group was first created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 5;
   */
  createTime?: Timestamp;

  /**
   * Version of the group entity that is being returned by the server.
   * When latest version is requested, this is the same as latest_version.
   *
   * @generated from field: string version = 6;
   */
  version = "";

  /**
   * Timestamp of the version of the group.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 7;
   */
  updateTime?: Timestamp;

  constructor(data?: PartialMessage<Group>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.Group";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "owner_account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "create_time", kind: "message", T: Timestamp },
    { no: 6, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "update_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Group {
    return new Group().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Group {
    return new Group().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Group {
    return new Group().fromJsonString(jsonString, options);
  }

  static equals(a: Group | PlainMessage<Group> | undefined, b: Group | PlainMessage<Group> | undefined): boolean {
    return proto3.util.equals(Group, a, b);
  }
}

