// @generated by protoc-gen-es v1.2.0 with parameter "target=ts,import_extension=none"
// @generated from file groups/v1alpha/groups.proto (package com.mintter.groups.v1alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * Role of a group member.
 *
 * @generated from enum com.mintter.groups.v1alpha.Role
 */
export enum Role {
  /**
   * Zero value which is an invalid role. This role is used to delete members,
   * and serves as a tombstone, because in our CRDT there's no way to truly delete something.
   *
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  ROLE_UNSPECIFIED = 0,

  /**
   * Editor role which allows members to manage content of the group.
   *
   * @generated from enum value: EDITOR = 1;
   */
  EDITOR = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Role)
proto3.util.setEnumType(Role, "com.mintter.groups.v1alpha.Role", [
  { no: 0, name: "ROLE_UNSPECIFIED" },
  { no: 1, name: "EDITOR" },
]);

/**
 * Request to create a group.
 *
 * @generated from message com.mintter.groups.v1alpha.CreateGroupRequest
 */
export class CreateGroupRequest extends Message<CreateGroupRequest> {
  /**
   * Required. Title of the new group.
   *
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * Optional. Description of the new group.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Optional. List of initial members for the new group.
   * Members can also be managed with separate requests after group is already created.
   *
   * @generated from field: map<string, com.mintter.groups.v1alpha.Role> members = 3;
   */
  members: { [key: string]: Role } = {};

  constructor(data?: PartialMessage<CreateGroupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.CreateGroupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "members", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(Role)} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateGroupRequest {
    return new CreateGroupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateGroupRequest {
    return new CreateGroupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateGroupRequest {
    return new CreateGroupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateGroupRequest | PlainMessage<CreateGroupRequest> | undefined, b: CreateGroupRequest | PlainMessage<CreateGroupRequest> | undefined): boolean {
    return proto3.util.equals(CreateGroupRequest, a, b);
  }
}

/**
 * Request to get a group.
 *
 * @generated from message com.mintter.groups.v1alpha.GetGroupRequest
 */
export class GetGroupRequest extends Message<GetGroupRequest> {
  /**
   * Required. ID of the group to get.
   * Must be a fully-qualified EID.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. Version of the group to get information about.
   * If empty, latest_version is assumed.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<GetGroupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.GetGroupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetGroupRequest {
    return new GetGroupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetGroupRequest {
    return new GetGroupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetGroupRequest {
    return new GetGroupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetGroupRequest | PlainMessage<GetGroupRequest> | undefined, b: GetGroupRequest | PlainMessage<GetGroupRequest> | undefined): boolean {
    return proto3.util.equals(GetGroupRequest, a, b);
  }
}

/**
 * Request to update a group.
 * Some fields are required, even if unchanged,
 * to distinguish between setting the value to an empty string, from an unchanged value.
 * Read the comments!
 *
 * @generated from message com.mintter.groups.v1alpha.UpdateGroupRequest
 */
export class UpdateGroupRequest extends Message<UpdateGroupRequest> {
  /**
   * ID of the group to update.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. Title of the Group.
   * Can be omitted if unchanged.
   *
   * @generated from field: string title = 2;
   */
  title = "";

  /**
   * Required. Description of the Group. Can be empty string.
   * Must always be provided, even if unchanged
   * to distinguish unchanged value from setting to empty string.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Optional. List of members to be updated in the Group.
   * Key is the member's Account ID,
   * value is the Role.
   * To remove a member from the group, set the role to unspecified.
   * Only updated records have to be sent, not all the members of the group.
   *
   * @generated from field: map<string, com.mintter.groups.v1alpha.Role> updated_members = 4;
   */
  updatedMembers: { [key: string]: Role } = {};

  /**
   * Optional. List of content to be updated in the Group.
   * Key is a pretty path on which the content is published,
   * value is a Hyperdocs URL of the content.
   * To unpublish content set the value to an empty string for a given pretty path.
   * Only updated records have to be sent, not all the content of the group.
   *
   * @generated from field: map<string, string> updated_content = 5;
   */
  updatedContent: { [key: string]: string } = {};

  constructor(data?: PartialMessage<UpdateGroupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.UpdateGroupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "updated_members", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(Role)} },
    { no: 5, name: "updated_content", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateGroupRequest {
    return new UpdateGroupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateGroupRequest {
    return new UpdateGroupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateGroupRequest {
    return new UpdateGroupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateGroupRequest | PlainMessage<UpdateGroupRequest> | undefined, b: UpdateGroupRequest | PlainMessage<UpdateGroupRequest> | undefined): boolean {
    return proto3.util.equals(UpdateGroupRequest, a, b);
  }
}

/**
 * Response to list members.
 *
 * @generated from message com.mintter.groups.v1alpha.ListMembersRequest
 */
export class ListMembersRequest extends Message<ListMembersRequest> {
  /**
   * Required. ID of the group to list members of.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. Version of the group to list members of.
   * If not specified, the latest version of the group
   * according to its members is used.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Optional. Maximum number of members to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing members from.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListMembersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListMembersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMembersRequest {
    return new ListMembersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListMembersRequest | PlainMessage<ListMembersRequest> | undefined, b: ListMembersRequest | PlainMessage<ListMembersRequest> | undefined): boolean {
    return proto3.util.equals(ListMembersRequest, a, b);
  }
}

/**
 * Response to list members.
 *
 * @generated from message com.mintter.groups.v1alpha.ListMembersResponse
 */
export class ListMembersResponse extends Message<ListMembersResponse> {
  /**
   * ID of the group owner.
   *
   * @generated from field: string owner_account_id = 1;
   */
  ownerAccountId = "";

  /**
   * List of members of the group.
   *
   * @generated from field: map<string, com.mintter.groups.v1alpha.Role> members = 2;
   */
  members: { [key: string]: Role } = {};

  /**
   * Token to continue listing members from.
   *
   * @generated from field: string next_page_token = 3;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListMembersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListMembersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "owner_account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "members", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "enum", T: proto3.getEnumType(Role)} },
    { no: 3, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMembersResponse {
    return new ListMembersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListMembersResponse | PlainMessage<ListMembersResponse> | undefined, b: ListMembersResponse | PlainMessage<ListMembersResponse> | undefined): boolean {
    return proto3.util.equals(ListMembersResponse, a, b);
  }
}

/**
 * Request to list content.
 *
 * @generated from message com.mintter.groups.v1alpha.ListContentRequest
 */
export class ListContentRequest extends Message<ListContentRequest> {
  /**
   * Required. ID of the group to list content of.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Optional. Version of the group to list content of.
   * If not specified, the latest version of the group
   * according to its members is used.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * Optional. Maximum number of content to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing content from.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListContentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListContentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListContentRequest {
    return new ListContentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListContentRequest {
    return new ListContentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListContentRequest {
    return new ListContentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListContentRequest | PlainMessage<ListContentRequest> | undefined, b: ListContentRequest | PlainMessage<ListContentRequest> | undefined): boolean {
    return proto3.util.equals(ListContentRequest, a, b);
  }
}

/**
 * Response to list content.
 *
 * @generated from message com.mintter.groups.v1alpha.ListContentResponse
 */
export class ListContentResponse extends Message<ListContentResponse> {
  /**
   * List of content of the group.
   * Key is the path and value is a Hyperdocs URL to the content.
   *
   * @generated from field: map<string, string> content = 1;
   */
  content: { [key: string]: string } = {};

  /**
   * Token to continue listing content from.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListContentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListContentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListContentResponse {
    return new ListContentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListContentResponse {
    return new ListContentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListContentResponse {
    return new ListContentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListContentResponse | PlainMessage<ListContentResponse> | undefined, b: ListContentResponse | PlainMessage<ListContentResponse> | undefined): boolean {
    return proto3.util.equals(ListContentResponse, a, b);
  }
}

/**
 * Request to list groups.
 *
 * @generated from message com.mintter.groups.v1alpha.ListGroupsRequest
 */
export class ListGroupsRequest extends Message<ListGroupsRequest> {
  /**
   * Optional. Maximum number of groups to return.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. Page token to continue listing groups from.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListGroupsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListGroupsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListGroupsRequest {
    return new ListGroupsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListGroupsRequest {
    return new ListGroupsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListGroupsRequest {
    return new ListGroupsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListGroupsRequest | PlainMessage<ListGroupsRequest> | undefined, b: ListGroupsRequest | PlainMessage<ListGroupsRequest> | undefined): boolean {
    return proto3.util.equals(ListGroupsRequest, a, b);
  }
}

/**
 * Response to list groups.
 *
 * @generated from message com.mintter.groups.v1alpha.ListGroupsResponse
 */
export class ListGroupsResponse extends Message<ListGroupsResponse> {
  /**
   * List of groups.
   *
   * @generated from field: repeated com.mintter.groups.v1alpha.Group groups = 1;
   */
  groups: Group[] = [];

  /**
   * Token to continue listing groups from.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListGroupsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.ListGroupsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groups", kind: "message", T: Group, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListGroupsResponse {
    return new ListGroupsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListGroupsResponse {
    return new ListGroupsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListGroupsResponse {
    return new ListGroupsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListGroupsResponse | PlainMessage<ListGroupsResponse> | undefined, b: ListGroupsResponse | PlainMessage<ListGroupsResponse> | undefined): boolean {
    return proto3.util.equals(ListGroupsResponse, a, b);
  }
}

/**
 * Group represents the basic information about a group entity.
 *
 * @generated from message com.mintter.groups.v1alpha.Group
 */
export class Group extends Message<Group> {
  /**
   * ID of the group.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Title of the group.
   *
   * @generated from field: string title = 2;
   */
  title = "";

  /**
   * Description of the group.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Account ID of the group owner.
   *
   * @generated from field: string owner_account_id = 4;
   */
  ownerAccountId = "";

  /**
   * Timestamp when the group was first created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 5;
   */
  createTime?: Timestamp;

  /**
   * Version of the group entity that is being returned by the server.
   * When latest version is requested, this is the same as latest_version.
   *
   * @generated from field: string version = 6;
   */
  version = "";

  /**
   * Latest version of the group according to the information from its owner and members
   * that we happen to have locally. Most of the time this is the version that should be used
   * to get the most recent group information.
   *
   * @generated from field: string latest_version = 7;
   */
  latestVersion = "";

  /**
   * Latest version of the group according to our trusted contacts.
   * It's possible that none of the group members is our trusted contact,
   * but still some of our trusted contacts might mutate the group entity for themselves,
   * in which case care must be taken while displaying the group entity to the user.
   * If none of the group members is our trusted contact, this version will be empty.
   * If only a subset of group members are our trusted contacts, this will be the head changes produced by them.
   *
   * @generated from field: string latest_local_trusted_version = 8;
   */
  latestLocalTrustedVersion = "";

  /**
   * Latest version of the group entity according to all the peers we happen to know about.
   * If no peer outside the group members produced any changes to the entity, this should be the same as latest_version.
   *
   * @generated from field: string latest_local_public_version = 9;
   */
  latestLocalPublicVersion = "";

  constructor(data?: PartialMessage<Group>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.mintter.groups.v1alpha.Group";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "owner_account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "create_time", kind: "message", T: Timestamp },
    { no: 6, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "latest_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "latest_local_trusted_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "latest_local_public_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Group {
    return new Group().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Group {
    return new Group().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Group {
    return new Group().fromJsonString(jsonString, options);
  }

  static equals(a: Group | PlainMessage<Group> | undefined, b: Group | PlainMessage<Group> | undefined): boolean {
    return proto3.util.equals(Group, a, b);
  }
}

