// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
//@ts-nocheck
/* eslint-disable */
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";
import _m0 from "protobufjs/minimal";
import { Empty } from "../../google/protobuf/empty";
import { Block } from "./documents";

/** Request to create a conversation. */
export interface CreateConversationRequest {
  /** Required. The ID of the publication for which the conversation should be created. */
  documentId: string;
  /**
   * Required. Selected portions in the original document which are being commented on.
   * At least one element must be present.
   */
  selectors: Selector[];
  /** Required. The first comment that starts the conversation. */
  initialComment: Block | undefined;
}

/** Request to add a comment. */
export interface AddCommentRequest {
  /** ID of the existing conversation. */
  conversationId: string;
  /**
   * Block corresponding to the text of the comment.
   * Using a block ID that already exists in the conversation will replace the comment.
   */
  comment: Block | undefined;
}

/** Request to delete a conversation. */
export interface DeleteConversationRequest {
  /** ID of the conversation to delete. */
  conversationId: string;
}

/** Request to resolve a conversation. */
export interface ResolveConversationRequest {
  /** ID of the conversation to resolve. */
  conversationId: string;
}

/** Response to resolve a conversation. */
export interface ResolveConversationResponse {
}

/** Request to delete a comment from a conversation. */
export interface DeleteCommentRequest {
  /** Required. ID of the conversation. */
  conversationId: string;
  /** Required. ID of the comment block to be deleted. */
  blockId: string;
}

/** Request to list conversations. */
export interface ListConversationsRequest {
  /** Required. Document ID for which conversations should be listed. */
  documentId: string;
  /** Optional. Number of results per page. */
  pageSize: number;
  /** Optional. Token for the page to return. */
  pageToken: string;
}

/** Response with a list of conversations. */
export interface ListConversationsResponse {
  /** Conversations matching the list request. */
  conversations: Conversation[];
  /** Token for the next page if there're any. */
  nextPageToken: string;
}

/**
 * Selector defines the selected portion of text in a given block as an open-ended interval [start, end).
 * If the interval is missing, the whole block is assumed.
 */
export interface Selector {
  /** Required. ID of the block in the original document which is being commented on. */
  blockId: string;
  /** Required. Specific block revision which is being commented. */
  blockRevision: string;
  /**
   * Optional. Start position of the selection within the block. Expressed in Unicode Code Points.
   * If start is specified, end must be specified as well. Must be start < end.
   */
  start: number;
  /**
   * Optional. End position of the selection within the block. Expressed in Unicode Code Points.
   * Required if start was specified. Must be greater than start if specified.
   */
  end: number;
}

/** Conversation is a set of comments anchored to a particular selection in a document. */
export interface Conversation {
  /** ID of the Conversation. */
  id: string;
  /** Selected portions of the original document which are being commented on. */
  selectors: Selector[];
  /**
   * List of comments in the conversation.
   * Ordered by time.
   */
  comments: Block[];
}

function createBaseCreateConversationRequest(): CreateConversationRequest {
  return { documentId: "", selectors: [], initialComment: undefined };
}

export const CreateConversationRequest = {
  encode(message: CreateConversationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    for (const v of message.selectors) {
      Selector.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.initialComment !== undefined) {
      Block.encode(message.initialComment, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        case 2:
          message.selectors.push(Selector.decode(reader, reader.uint32()));
          break;
        case 3:
          message.initialComment = Block.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateConversationRequest {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
      selectors: Array.isArray(object?.selectors) ? object.selectors.map((e: any) => Selector.fromJSON(e)) : [],
      initialComment: isSet(object.initialComment) ? Block.fromJSON(object.initialComment) : undefined,
    };
  },

  toJSON(message: CreateConversationRequest): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    if (message.selectors) {
      obj.selectors = message.selectors.map((e) => e ? Selector.toJSON(e) : undefined);
    } else {
      obj.selectors = [];
    }
    message.initialComment !== undefined &&
      (obj.initialComment = message.initialComment ? Block.toJSON(message.initialComment) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CreateConversationRequest>, I>>(object: I): CreateConversationRequest {
    const message = createBaseCreateConversationRequest();
    message.documentId = object.documentId ?? "";
    message.selectors = object.selectors?.map((e) => Selector.fromPartial(e)) || [];
    message.initialComment = (object.initialComment !== undefined && object.initialComment !== null)
      ? Block.fromPartial(object.initialComment)
      : undefined;
    return message;
  },
};

function createBaseAddCommentRequest(): AddCommentRequest {
  return { conversationId: "", comment: undefined };
}

export const AddCommentRequest = {
  encode(message: AddCommentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.comment !== undefined) {
      Block.encode(message.comment, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddCommentRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationId = reader.string();
          break;
        case 2:
          message.comment = Block.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddCommentRequest {
    return {
      conversationId: isSet(object.conversationId) ? String(object.conversationId) : "",
      comment: isSet(object.comment) ? Block.fromJSON(object.comment) : undefined,
    };
  },

  toJSON(message: AddCommentRequest): unknown {
    const obj: any = {};
    message.conversationId !== undefined && (obj.conversationId = message.conversationId);
    message.comment !== undefined && (obj.comment = message.comment ? Block.toJSON(message.comment) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AddCommentRequest>, I>>(object: I): AddCommentRequest {
    const message = createBaseAddCommentRequest();
    message.conversationId = object.conversationId ?? "";
    message.comment = (object.comment !== undefined && object.comment !== null)
      ? Block.fromPartial(object.comment)
      : undefined;
    return message;
  },
};

function createBaseDeleteConversationRequest(): DeleteConversationRequest {
  return { conversationId: "" };
}

export const DeleteConversationRequest = {
  encode(message: DeleteConversationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteConversationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteConversationRequest {
    return { conversationId: isSet(object.conversationId) ? String(object.conversationId) : "" };
  },

  toJSON(message: DeleteConversationRequest): unknown {
    const obj: any = {};
    message.conversationId !== undefined && (obj.conversationId = message.conversationId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteConversationRequest>, I>>(object: I): DeleteConversationRequest {
    const message = createBaseDeleteConversationRequest();
    message.conversationId = object.conversationId ?? "";
    return message;
  },
};

function createBaseResolveConversationRequest(): ResolveConversationRequest {
  return { conversationId: "" };
}

export const ResolveConversationRequest = {
  encode(message: ResolveConversationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResolveConversationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ResolveConversationRequest {
    return { conversationId: isSet(object.conversationId) ? String(object.conversationId) : "" };
  },

  toJSON(message: ResolveConversationRequest): unknown {
    const obj: any = {};
    message.conversationId !== undefined && (obj.conversationId = message.conversationId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ResolveConversationRequest>, I>>(object: I): ResolveConversationRequest {
    const message = createBaseResolveConversationRequest();
    message.conversationId = object.conversationId ?? "";
    return message;
  },
};

function createBaseResolveConversationResponse(): ResolveConversationResponse {
  return {};
}

export const ResolveConversationResponse = {
  encode(_: ResolveConversationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResolveConversationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ResolveConversationResponse {
    return {};
  },

  toJSON(_: ResolveConversationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ResolveConversationResponse>, I>>(_: I): ResolveConversationResponse {
    const message = createBaseResolveConversationResponse();
    return message;
  },
};

function createBaseDeleteCommentRequest(): DeleteCommentRequest {
  return { conversationId: "", blockId: "" };
}

export const DeleteCommentRequest = {
  encode(message: DeleteCommentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.blockId !== "") {
      writer.uint32(18).string(message.blockId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteCommentRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversationId = reader.string();
          break;
        case 2:
          message.blockId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteCommentRequest {
    return {
      conversationId: isSet(object.conversationId) ? String(object.conversationId) : "",
      blockId: isSet(object.blockId) ? String(object.blockId) : "",
    };
  },

  toJSON(message: DeleteCommentRequest): unknown {
    const obj: any = {};
    message.conversationId !== undefined && (obj.conversationId = message.conversationId);
    message.blockId !== undefined && (obj.blockId = message.blockId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DeleteCommentRequest>, I>>(object: I): DeleteCommentRequest {
    const message = createBaseDeleteCommentRequest();
    message.conversationId = object.conversationId ?? "";
    message.blockId = object.blockId ?? "";
    return message;
  },
};

function createBaseListConversationsRequest(): ListConversationsRequest {
  return { documentId: "", pageSize: 0, pageToken: "" };
}

export const ListConversationsRequest = {
  encode(message: ListConversationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListConversationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.documentId = reader.string();
          break;
        case 3:
          message.pageSize = reader.int32();
          break;
        case 4:
          message.pageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListConversationsRequest {
    return {
      documentId: isSet(object.documentId) ? String(object.documentId) : "",
      pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? String(object.pageToken) : "",
    };
  },

  toJSON(message: ListConversationsRequest): unknown {
    const obj: any = {};
    message.documentId !== undefined && (obj.documentId = message.documentId);
    message.pageSize !== undefined && (obj.pageSize = Math.round(message.pageSize));
    message.pageToken !== undefined && (obj.pageToken = message.pageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListConversationsRequest>, I>>(object: I): ListConversationsRequest {
    const message = createBaseListConversationsRequest();
    message.documentId = object.documentId ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListConversationsResponse(): ListConversationsResponse {
  return { conversations: [], nextPageToken: "" };
}

export const ListConversationsResponse = {
  encode(message: ListConversationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.conversations) {
      Conversation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListConversationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.conversations.push(Conversation.decode(reader, reader.uint32()));
          break;
        case 2:
          message.nextPageToken = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListConversationsResponse {
    return {
      conversations: Array.isArray(object?.conversations)
        ? object.conversations.map((e: any) => Conversation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListConversationsResponse): unknown {
    const obj: any = {};
    if (message.conversations) {
      obj.conversations = message.conversations.map((e) => e ? Conversation.toJSON(e) : undefined);
    } else {
      obj.conversations = [];
    }
    message.nextPageToken !== undefined && (obj.nextPageToken = message.nextPageToken);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ListConversationsResponse>, I>>(object: I): ListConversationsResponse {
    const message = createBaseListConversationsResponse();
    message.conversations = object.conversations?.map((e) => Conversation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSelector(): Selector {
  return { blockId: "", blockRevision: "", start: 0, end: 0 };
}

export const Selector = {
  encode(message: Selector, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockId !== "") {
      writer.uint32(10).string(message.blockId);
    }
    if (message.blockRevision !== "") {
      writer.uint32(18).string(message.blockRevision);
    }
    if (message.start !== 0) {
      writer.uint32(24).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(32).int32(message.end);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Selector {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blockId = reader.string();
          break;
        case 2:
          message.blockRevision = reader.string();
          break;
        case 3:
          message.start = reader.int32();
          break;
        case 4:
          message.end = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Selector {
    return {
      blockId: isSet(object.blockId) ? String(object.blockId) : "",
      blockRevision: isSet(object.blockRevision) ? String(object.blockRevision) : "",
      start: isSet(object.start) ? Number(object.start) : 0,
      end: isSet(object.end) ? Number(object.end) : 0,
    };
  },

  toJSON(message: Selector): unknown {
    const obj: any = {};
    message.blockId !== undefined && (obj.blockId = message.blockId);
    message.blockRevision !== undefined && (obj.blockRevision = message.blockRevision);
    message.start !== undefined && (obj.start = Math.round(message.start));
    message.end !== undefined && (obj.end = Math.round(message.end));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Selector>, I>>(object: I): Selector {
    const message = createBaseSelector();
    message.blockId = object.blockId ?? "";
    message.blockRevision = object.blockRevision ?? "";
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  },
};

function createBaseConversation(): Conversation {
  return { id: "", selectors: [], comments: [] };
}

export const Conversation = {
  encode(message: Conversation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.selectors) {
      Selector.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.comments) {
      Block.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.selectors.push(Selector.decode(reader, reader.uint32()));
          break;
        case 3:
          message.comments.push(Block.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      selectors: Array.isArray(object?.selectors) ? object.selectors.map((e: any) => Selector.fromJSON(e)) : [],
      comments: Array.isArray(object?.comments) ? object.comments.map((e: any) => Block.fromJSON(e)) : [],
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    if (message.selectors) {
      obj.selectors = message.selectors.map((e) => e ? Selector.toJSON(e) : undefined);
    } else {
      obj.selectors = [];
    }
    if (message.comments) {
      obj.comments = message.comments.map((e) => e ? Block.toJSON(e) : undefined);
    } else {
      obj.comments = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Conversation>, I>>(object: I): Conversation {
    const message = createBaseConversation();
    message.id = object.id ?? "";
    message.selectors = object.selectors?.map((e) => Selector.fromPartial(e)) || [];
    message.comments = object.comments?.map((e) => Block.fromPartial(e)) || [];
    return message;
  },
};

/** Comments service provides the way to add comments to publications. */
export interface Comments {
  /** Creates a new conversation about a particular selection in a document. */
  createConversation(request: DeepPartial<CreateConversationRequest>, metadata?: grpc.Metadata): Promise<Conversation>;
  /** Adds a comment to a previously existing conversation. */
  addComment(request: DeepPartial<AddCommentRequest>, metadata?: grpc.Metadata): Promise<Block>;
  /** Deletes an existing conversation. */
  deleteConversation(request: DeepPartial<DeleteConversationRequest>, metadata?: grpc.Metadata): Promise<Empty>;
  /** Marks an existing conversation as resolved. */
  resolveConversation(
    request: DeepPartial<ResolveConversationRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ResolveConversationResponse>;
  /** Deletes a comment from a conversation. */
  deleteComment(request: DeepPartial<DeleteCommentRequest>, metadata?: grpc.Metadata): Promise<Empty>;
  /** Lists conversations of a particular document. */
  listConversations(
    request: DeepPartial<ListConversationsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListConversationsResponse>;
}

export class CommentsClientImpl implements Comments {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.createConversation = this.createConversation.bind(this);
    this.addComment = this.addComment.bind(this);
    this.deleteConversation = this.deleteConversation.bind(this);
    this.resolveConversation = this.resolveConversation.bind(this);
    this.deleteComment = this.deleteComment.bind(this);
    this.listConversations = this.listConversations.bind(this);
  }

  createConversation(request: DeepPartial<CreateConversationRequest>, metadata?: grpc.Metadata): Promise<Conversation> {
    return this.rpc.unary(CommentsCreateConversationDesc, CreateConversationRequest.fromPartial(request), metadata);
  }

  addComment(request: DeepPartial<AddCommentRequest>, metadata?: grpc.Metadata): Promise<Block> {
    return this.rpc.unary(CommentsAddCommentDesc, AddCommentRequest.fromPartial(request), metadata);
  }

  deleteConversation(request: DeepPartial<DeleteConversationRequest>, metadata?: grpc.Metadata): Promise<Empty> {
    return this.rpc.unary(CommentsDeleteConversationDesc, DeleteConversationRequest.fromPartial(request), metadata);
  }

  resolveConversation(
    request: DeepPartial<ResolveConversationRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ResolveConversationResponse> {
    return this.rpc.unary(CommentsResolveConversationDesc, ResolveConversationRequest.fromPartial(request), metadata);
  }

  deleteComment(request: DeepPartial<DeleteCommentRequest>, metadata?: grpc.Metadata): Promise<Empty> {
    return this.rpc.unary(CommentsDeleteCommentDesc, DeleteCommentRequest.fromPartial(request), metadata);
  }

  listConversations(
    request: DeepPartial<ListConversationsRequest>,
    metadata?: grpc.Metadata,
  ): Promise<ListConversationsResponse> {
    return this.rpc.unary(CommentsListConversationsDesc, ListConversationsRequest.fromPartial(request), metadata);
  }
}

export const CommentsDesc = { serviceName: "com.mintter.documents.v1alpha.Comments" };

export const CommentsCreateConversationDesc: UnaryMethodDefinitionish = {
  methodName: "CreateConversation",
  service: CommentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateConversationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Conversation.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const CommentsAddCommentDesc: UnaryMethodDefinitionish = {
  methodName: "AddComment",
  service: CommentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AddCommentRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Block.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const CommentsDeleteConversationDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteConversation",
  service: CommentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteConversationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Empty.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const CommentsResolveConversationDesc: UnaryMethodDefinitionish = {
  methodName: "ResolveConversation",
  service: CommentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ResolveConversationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...ResolveConversationResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const CommentsDeleteCommentDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteComment",
  service: CommentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteCommentRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...Empty.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

export const CommentsListConversationsDesc: UnaryMethodDefinitionish = {
  methodName: "ListConversations",
  service: CommentsDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ListConversationsRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      return {
        ...ListConversationsResponse.decode(data),
        toObject() {
          return this;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message);
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}
