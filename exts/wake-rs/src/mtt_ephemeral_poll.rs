//
// This file was automatically generated by witx-codegen - Do not edit manually.
//

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum Error {
  WasiError(i32),
}
impl std::error::Error for Error {}
impl std::fmt::Display for Error {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      Error::WasiError(e) => write!(f, "Wasi error {}", e),
    }
  }
}

pub type WasiHandle = i32;
pub type Char8 = u8;
pub type Char32 = u32;
pub type WasiPtr<T> = *const T;
pub type WasiMutPtr<T> = *mut T;
pub type WasiStringBytesPtr = WasiPtr<Char8>;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct WasiSlice<T> {
  ptr: WasiPtr<T>,
  len: usize,
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct WasiMutSlice<T> {
  ptr: WasiMutPtr<T>,
  len: usize,
}

impl<T> WasiSlice<T> {
  pub fn as_slice(&self) -> &[T] {
    unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
  }

  pub fn from_slice(&self, slice: &[T]) -> Self {
    WasiSlice {
      ptr: slice.as_ptr() as _,
      len: slice.len(),
    }
  }
}

impl<T> WasiMutSlice<T> {
  pub fn as_slice(&self) -> &[T] {
    unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
  }

  pub fn as_mut_slice(&self) -> &mut [T] {
    unsafe { std::slice::from_raw_parts_mut(self.ptr, self.len) }
  }

  pub fn from_slice(&self, slice: &[T]) -> Self {
    WasiMutSlice {
      ptr: slice.as_ptr() as _,
      len: slice.len(),
    }
  }

  pub fn from_mut_slice(&self, slice: &mut [T]) -> Self {
    WasiMutSlice {
      ptr: slice.as_mut_ptr(),
      len: slice.len(),
    }
  }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct WasiString {
  pub ptr: WasiStringBytesPtr,
  pub len: usize,
}

impl<T: AsRef<str>> From<T> for WasiString {
  fn from(s: T) -> Self {
    let s = s.as_ref();
    WasiString {
      ptr: s.as_ptr() as _,
      len: s.len(),
    }
  }
}

impl WasiString {
  pub fn as_str(&self) -> Result<&str, std::str::Utf8Error> {
    std::str::from_utf8(unsafe { std::slice::from_raw_parts(self.ptr, self.len) })
  }

  pub fn as_slice(&self) -> &[u8] {
    unsafe { std::slice::from_raw_parts(self.ptr, self.len) }
  }

  pub fn from_slice(&self, slice: &[u8]) -> Self {
    WasiString {
      ptr: slice.as_ptr() as _,
      len: slice.len(),
    }
  }
}

// ---------------------- Module: [mtt_ephemeral_poll] ----------------------

/// An array size.
///
/// Note: This is similar to `size_t` in POSIX.
pub type Size = usize;

/// Error codes returned by functions.
pub type MttErrno = u16;

#[allow(non_snake_case)]
pub mod MTT_ERRNO {
  use super::MttErrno;
  pub const SUCCESS: MttErrno = 0;
  pub const ILSEQ: MttErrno = 1;
  pub const INVAL: MttErrno = 2;
  pub const OVERFLOW: MttErrno = 3;
  pub const IO: MttErrno = 4;
  pub const FAULT: MttErrno = 5;
}

/// User-provided value that may be attached to objects that is retained when
/// extracted from the implementation.
pub type Userdata = u64;

/// Type of a subscription to an event or its occurrence.
pub type Eventtype = u8;

#[allow(non_snake_case)]
pub mod EVENTTYPE {
  use super::Eventtype;
  pub const WINDOW_EVENT: Eventtype = 0;
}

#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SubscriptionWindowEvent {
  pub event: WasiPtr<Char8>,
  pub event_len: Size,
}

/// The contents of a `subscription`.
#[repr(C)]
pub union SubscriptionUMember {
  window_event: SubscriptionWindowEvent, // if tag=0
}

#[repr(C, packed)]
pub struct SubscriptionU {
  pub tag: u8,
  __pad8_0: u8,
  __pad16_0: u16,
  __pad64_0: u64,
  pub member: std::mem::MaybeUninit<SubscriptionUMember>,
}

impl SubscriptionU {
  fn new(tag: u8) -> Self {
    let mut tu = unsafe { std::mem::zeroed::<Self>() };
    tu.tag = tag;
    tu
  }

  // --- window_event: SubscriptionWindowEvent if tag=0

  pub fn new_window_event(val: SubscriptionWindowEvent) -> Self {
    let mut tu = Self::new(0);
    tu.member = std::mem::MaybeUninit::new(SubscriptionUMember { window_event: val });
    tu
  }

  pub fn into_window_event(self) -> SubscriptionWindowEvent {
    assert_eq!(self.tag, 0);
    unsafe { self.member.assume_init().window_event }
  }

  pub fn set_window_event(&mut self, val: SubscriptionWindowEvent) {
    assert_eq!(self.tag, 0);
    let uval = SubscriptionUMember { window_event: val };
    unsafe { *self.member.as_mut_ptr() = uval };
  }

  pub fn is_window_event(&self) -> bool {
    self.tag == 0
  }
}

/// Subscription to an event.
#[repr(C, packed)]
pub struct Subscription {
  pub u: SubscriptionU,
}

/// The contents of an `event`.
pub type EventU = u8;

#[allow(non_snake_case)]
pub mod EVENT_U {
  use super::EventU;
  pub const WINDOW_EVENT: EventU = 0;
}

/// An event that occurred.
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct Event {
  pub error: MttErrno,
  pub u: EventU,
}

/// Concurrently poll for the occurrence of a set of events.
///
/// If `nsubscriptions` is 0, returns `errno::inval`.
pub fn oneoff(in_: WasiPtr<Subscription>, nsubscriptions: Size) -> Result<Event, Error> {
  #[link(wasm_import_module = "mtt_ephemeral_poll")]
  extern "C" {
    fn oneoff(
      in_: WasiPtr<Subscription>,
      nsubscriptions: Size,
      result_ptr: WasiMutPtr<Event>,
    ) -> MttErrno;
  }
  let mut result_ptr = std::mem::MaybeUninit::uninit();
  let res = unsafe { oneoff(in_, nsubscriptions, result_ptr.as_mut_ptr()) };
  if res != 0 {
    return Err(Error::WasiError(res as _));
  }
  Ok(unsafe { result_ptr.assume_init() })
}
