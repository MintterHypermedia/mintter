/// <reference types="assemblyscript/std/assembly" />
/*
 * This file was automatically generated by witx-codegen - Do not edit manually.
 */

export type WasiHandle = i32;
export type Char8 = u8;
export type Char32 = u32;
export type WasiPtr<T> = usize;
export type WasiMutPtr<T> = usize;
export type WasiStringBytesPtr = WasiPtr<Char8>;

// @ts-ignore: decorator
@unmanaged
export class WasiString {
    ptr: WasiStringBytesPtr;
    length: usize;

    constructor(str: string) {
        let wasiString = String.UTF8.encode(str, false);
        // @ts-ignore: cast
        this.ptr = changetype<WasiStringBytesPtr>(wasiString);
        this.length = wasiString.byteLength;
    }

    toString(): string {
        let tmp = new ArrayBuffer(this.length as u32);
        memory.copy(changetype<usize>(tmp), this.ptr, this.length);
        return String.UTF8.decode(tmp);
    }
}

// @ts-ignore: decorator
@unmanaged
export class WasiSlice<T> {
    ptr: WasiPtr<T>;
    length: usize;

    constructor(array: ArrayBufferView) {
        // @ts-ignore: cast
        this.ptr = array.dataStart;
        this.length = array.byteLength;
    }
}

// @ts-ignore: decorator
@unmanaged
export class WasiMutSlice<T> {
    ptr: WasiMutPtr<T>;
    length: usize;

    constructor(array: ArrayBufferView) {
        // @ts-ignore: cast
        this.ptr = array.dataStart;
        this.length = array.byteLength;
    }
}

/*
 * ---------------------- Module: [mtt_ephemeral_poll] ----------------------
 */

/**
 * An array size.
 *
 * Note: This is similar to `size_t` in POSIX.
 */
export type Size = usize;

/**
 * Error codes returned by functions.
 */
export type MttErrno = u16;

export namespace MttErrno {
    export const SUCCESS: MttErrno = 0;
    export const ILSEQ: MttErrno = 1;
    export const INVAL: MttErrno = 2;
    export const OVERFLOW: MttErrno = 3;
    export const IO: MttErrno = 4;
    export const FAULT: MttErrno = 5;
}

/**
 * User-provided value that may be attached to objects that is retained when
 * extracted from the implementation.
 */
export type Userdata = u64;

/**
 * Type of a subscription to an event or its occurrence.
 */
export type Eventtype = u8;

export namespace Eventtype {
    export const WINDOW_EVENT: Eventtype = 0;
}

// @ts-ignore: decorator
@unmanaged
export class SubscriptionWindowEvent {
    event: WasiMutPtr<Char8>;
    event_len: Size;
}


/**
 * The contents of a `subscription`.
 */
// @ts-ignore: decorator
@unmanaged
export class SubscriptionU {
    tag: u8;
    private __pad8_0: u8;
    private __pad16_0: u16;
    private __pad64_0: u64;

    constructor(tag: u8) {
        this.tag = tag;
        memory.fill(changetype<usize>(this) + 4, 0, 8);
    }

    // @ts-ignore: default
    static new<T>(tag: u8, val: T = 0): SubscriptionU {
        let tu = new SubscriptionU(tag);
        tu.set(val);
        return tu;
    }

    get<T>(): T {
        // @ts-ignore: cast
        let valBuf = changetype<usize>(this) + 4;
        if (isReference<T>()) {
            return changetype<T>(valBuf);
        } else {
            return load<T>(valBuf);
        }
    }

    // @ts-ignore: default
    set<T>(val: T = 0): void {
        // @ts-ignore: cast
        let valBuf = changetype<usize>(this) + 4;
        memory.fill(valBuf, 0, 8);
        if (isReference<T>()) {
            (val !== null) && memory.copy(valBuf, changetype<usize>(val), offsetof<T>());
        } else {
            store<T>(valBuf, val)
        }
    }

    // --- window_event: SubscriptionWindowEvent if tag=0

    static windowEvent(val: SubscriptionWindowEvent): SubscriptionU {
        return SubscriptionU.new(0, val);
    }

    setWindowEvent(val: SubscriptionWindowEvent): void {
        this.tag = 0;
        this.set(val);
    }

    isWindowEvent(): bool {
        return this.tag === 0;
    }

    getWindowEvent(): SubscriptionWindowEvent {
        return this.get<SubscriptionWindowEvent>();
    }
}


/**
 * Subscription to an event.
 */
// @ts-ignore: decorator
@unmanaged
export class Subscription {
    u: SubscriptionU;
}


/**
 * The contents of an `event`.
 */
export type EventU = u8;

export namespace EventU {
    export const WINDOW_EVENT: EventU = 0;
}

/**
 * An event that occurred.
 */
// @ts-ignore: decorator
@unmanaged
export class Event {
    error: MttErrno;
    u: EventU;
}


/**
 * Concurrently poll for the occurrence of a set of events.
 *
 * If `nsubscriptions` is 0, returns `errno::inval`.
 */
// @ts-ignore: decorator
@unsafe
// @ts-ignore: decorator
@external("mtt_ephemeral_poll", "oneoff")
export declare function oneoff(
    in_: WasiPtr<Subscription>,
    nsubscriptions: Size,
    result_ptr: WasiMutPtr<Event>
): MttErrno;

