// Code generated by sqlitegen. DO NOT EDIT.

package vcssql

import (
	"errors"
	"fmt"

	"crawshaw.io/sqlite"
	"mintter/backend/db/sqlitegen"
)

var _ = errors.New

type AccountsLookupPKResult struct {
	AccountsID int
}

func AccountsLookupPK(conn *sqlite.Conn, accountsMultihash []byte) (AccountsLookupPKResult, error) {
	const query = `SELECT accounts.id
FROM accounts
WHERE accounts.multihash = :accountsMultihash`

	var out AccountsLookupPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accountsMultihash", accountsMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("AccountsLookupPK: more than one result return for a single-kind query")
		}

		out.AccountsID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsLookupPK: %w", err)
	}

	return out, err
}

type AccountsInsertPKResult struct {
	AccountsID int
}

func AccountsInsertPK(conn *sqlite.Conn, accountsMultihash []byte) (AccountsInsertPKResult, error) {
	const query = `INSERT INTO accounts (multihash)
VALUES (:accountsMultihash) RETURNING accounts.id`

	var out AccountsInsertPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accountsMultihash", accountsMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("AccountsInsertPK: more than one result return for a single-kind query")
		}

		out.AccountsID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsInsertPK: %w", err)
	}

	return out, err
}

type AccountsGetForDeviceResult struct {
	AccountsID        int
	AccountsMultihash []byte
}

func AccountsGetForDevice(conn *sqlite.Conn, devicesMultihash []byte) (AccountsGetForDeviceResult, error) {
	const query = `SELECT accounts.id, accounts.multihash
FROM accounts
JOIN account_devices ON account_devices.account_id = accounts.id
WHERE account_devices.device_id = COALESCE((SELECT devices.id FROM devices WHERE devices.multihash = :devicesMultihash LIMIT 1), -1000)`

	var out AccountsGetForDeviceResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":devicesMultihash", devicesMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("AccountsGetForDevice: more than one result return for a single-kind query")
		}

		out.AccountsID = stmt.ColumnInt(0)
		out.AccountsMultihash = stmt.ColumnBytes(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsGetForDevice: %w", err)
	}

	return out, err
}

type AccountsListResult struct {
	AccountsID        int
	AccountsMultihash []byte
}

func AccountsList(conn *sqlite.Conn, ownAccountMultihash []byte) ([]AccountsListResult, error) {
	const query = `SELECT accounts.id, accounts.multihash
FROM accounts
WHERE accounts.multihash != :ownAccountMultihash`

	var out []AccountsListResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ownAccountMultihash", ownAccountMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, AccountsListResult{
			AccountsID:        stmt.ColumnInt(0),
			AccountsMultihash: stmt.ColumnBytes(1),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsList: %w", err)
	}

	return out, err
}

func AccountsIndexProfile(conn *sqlite.Conn, profilesAccountID int, profilesAlias string, profilesEmail string, profilesBio string, profilesChangeID int) error {
	const query = `INSERT OR IGNORE INTO profiles (account_id, alias, email, bio, change_id)
VALUES (:profilesAccountID, :profilesAlias, :profilesEmail, :profilesBio, :profilesChangeID)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":profilesAccountID", profilesAccountID)
		stmt.SetText(":profilesAlias", profilesAlias)
		stmt.SetText(":profilesEmail", profilesEmail)
		stmt.SetText(":profilesBio", profilesBio)
		stmt.SetInt(":profilesChangeID", profilesChangeID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsIndexProfile: %w", err)
	}

	return err
}

type AccountsListProfilesResult struct {
	ProfilesAccountID int
	ProfilesAlias     string
	ProfilesEmail     string
	ProfilesBio       string
	ProfilesChangeID  int
}

func AccountsListProfiles(conn *sqlite.Conn) ([]AccountsListProfilesResult, error) {
	const query = `SELECT profiles.account_id, profiles.alias, profiles.email, profiles.bio, profiles.change_id
FROM profiles
`

	var out []AccountsListProfilesResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, AccountsListProfilesResult{
			ProfilesAccountID: stmt.ColumnInt(0),
			ProfilesAlias:     stmt.ColumnText(1),
			ProfilesEmail:     stmt.ColumnText(2),
			ProfilesBio:       stmt.ColumnText(3),
			ProfilesChangeID:  stmt.ColumnInt(4),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsListProfiles: %w", err)
	}

	return out, err
}

func ContentLinksInsert(conn *sqlite.Conn, contentLinksSourceDocumentID int, contentLinksSourceBlockID string, contentLinksSourceChangeID int, contentLinksSourceVersion string, contentLinksTargetDocumentID int, contentLinksTargetBlockID string, contentLinksTargetVersion string) error {
	const query = `INSERT OR IGNORE INTO content_links (source_document_id, source_block_id, source_change_id, source_version, target_document_id, target_block_id, target_version)
VALUES (:contentLinksSourceDocumentID, :contentLinksSourceBlockID, :contentLinksSourceChangeID, :contentLinksSourceVersion, :contentLinksTargetDocumentID, :contentLinksTargetBlockID, :contentLinksTargetVersion)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":contentLinksSourceDocumentID", contentLinksSourceDocumentID)
		stmt.SetText(":contentLinksSourceBlockID", contentLinksSourceBlockID)
		stmt.SetInt(":contentLinksSourceChangeID", contentLinksSourceChangeID)
		stmt.SetText(":contentLinksSourceVersion", contentLinksSourceVersion)
		stmt.SetInt(":contentLinksTargetDocumentID", contentLinksTargetDocumentID)
		stmt.SetText(":contentLinksTargetBlockID", contentLinksTargetBlockID)
		stmt.SetText(":contentLinksTargetVersion", contentLinksTargetVersion)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ContentLinksInsert: %w", err)
	}

	return err
}

type BacklinksListByTargetDocumentResult struct {
	SourceDocumentMultihash   []byte
	ContentLinksSourceBlockID string
	ContentLinksSourceVersion string
	TargetDocumentMultihash   []byte
	ContentLinksTargetBlockID string
	ContentLinksTargetVersion string
}

func BacklinksListByTargetDocument(conn *sqlite.Conn, targetDocumentID int, depth int) ([]BacklinksListByTargetDocumentResult, error) {
	const query = `WITH RECURSIVE parent AS (SELECT content_links.*, 0 AS level FROM content_links WHERE content_links.target_document_id = :targetDocumentID UNION ALL SELECT content_links.*, parent.level + 1 AS child_level FROM content_links, parent WHERE parent.source_document_id = content_links.target_document_id AND child_level <= :depth ORDER BY child_level) SELECT s.multihash, content_links.source_block_id, content_links.source_version, t.multihash, content_links.target_block_id, content_links.target_version FROM parent AS content_links JOIN ipfs_blocks s ON s.id = content_links.source_document_id JOIN ipfs_blocks t on t.id = content_links.target_document_id WHERE content_links.source_document_id != :targetDocumentID`

	var out []BacklinksListByTargetDocumentResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":targetDocumentID", targetDocumentID)
		stmt.SetInt(":depth", depth)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, BacklinksListByTargetDocumentResult{
			SourceDocumentMultihash:   stmt.ColumnBytes(0),
			ContentLinksSourceBlockID: stmt.ColumnText(1),
			ContentLinksSourceVersion: stmt.ColumnText(2),
			TargetDocumentMultihash:   stmt.ColumnBytes(3),
			ContentLinksTargetBlockID: stmt.ColumnText(4),
			ContentLinksTargetVersion: stmt.ColumnText(5),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: BacklinksListByTargetDocument: %w", err)
	}

	return out, err
}

func ContentLinksDelete(conn *sqlite.Conn, contentLinksSourceDocumentID int, contentLinksSourceBlockID string) error {
	const query = `DELETE FROM content_links
WHERE content_links.source_document_id = :contentLinksSourceDocumentID
AND content_links.source_block_id = :contentLinksSourceBlockID`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":contentLinksSourceDocumentID", contentLinksSourceDocumentID)
		stmt.SetText(":contentLinksSourceBlockID", contentLinksSourceBlockID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ContentLinksDelete: %w", err)
	}

	return err
}

type DevicesLookupPKResult struct {
	DevicesID int
}

func DevicesLookupPK(conn *sqlite.Conn, devicesMultihash []byte) (DevicesLookupPKResult, error) {
	const query = `SELECT devices.id
FROM devices
WHERE devices.multihash = :devicesMultihash`

	var out DevicesLookupPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":devicesMultihash", devicesMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("DevicesLookupPK: more than one result return for a single-kind query")
		}

		out.DevicesID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DevicesLookupPK: %w", err)
	}

	return out, err
}

type DevicesInsertPKResult struct {
	DevicesID int
}

func DevicesInsertPK(conn *sqlite.Conn, devicesMultihash []byte) (DevicesInsertPKResult, error) {
	const query = `INSERT INTO devices (multihash)
VALUES (:devicesMultihash) RETURNING devices.id`

	var out DevicesInsertPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":devicesMultihash", devicesMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("DevicesInsertPK: more than one result return for a single-kind query")
		}

		out.DevicesID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DevicesInsertPK: %w", err)
	}

	return out, err
}

func AccountDevicesInsertOrIgnore(conn *sqlite.Conn, accountDevicesAccountID int, accountDevicesDeviceID int, accountDevicesProof []byte) error {
	const query = `INSERT OR IGNORE INTO account_devices (account_id, device_id, proof) VALUES (:accountDevicesAccountID, :accountDevicesDeviceID, :accountDevicesProof)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":accountDevicesAccountID", accountDevicesAccountID)
		stmt.SetInt(":accountDevicesDeviceID", accountDevicesDeviceID)
		stmt.SetBytes(":accountDevicesProof", accountDevicesProof)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountDevicesInsertOrIgnore: %w", err)
	}

	return err
}

type AccountDevicesListResult struct {
	DevicesMultihash  []byte
	AccountsMultihash []byte
}

func AccountDevicesList(conn *sqlite.Conn) ([]AccountDevicesListResult, error) {
	const query = `SELECT devices.multihash, accounts.multihash
FROM account_devices
JOIN accounts ON accounts.id = account_devices.account_id JOIN devices ON devices.id = account_devices.device_id`

	var out []AccountDevicesListResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, AccountDevicesListResult{
			DevicesMultihash:  stmt.ColumnBytes(0),
			AccountsMultihash: stmt.ColumnBytes(1),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountDevicesList: %w", err)
	}

	return out, err
}

type DevicesListResult struct {
	DevicesMultihash        []byte
	AccountDevicesDeviceID  int
	AccountDevicesAccountID int
}

func DevicesList(conn *sqlite.Conn) ([]DevicesListResult, error) {
	const query = `SELECT devices.multihash, account_devices.device_id, account_devices.account_id
FROM account_devices
JOIN devices ON devices.id = account_devices.device_id`

	var out []DevicesListResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, DevicesListResult{
			DevicesMultihash:        stmt.ColumnBytes(0),
			AccountDevicesDeviceID:  stmt.ColumnInt(1),
			AccountDevicesAccountID: stmt.ColumnInt(2),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DevicesList: %w", err)
	}

	return out, err
}

type AccountDevicesGetProofResult struct {
	AccountDevicesProof []byte
}

func AccountDevicesGetProof(conn *sqlite.Conn, accountsMultihash []byte, devicesMultihash []byte) (AccountDevicesGetProofResult, error) {
	const query = `SELECT account_devices.proof
FROM account_devices
WHERE account_devices.account_id = COALESCE((SELECT accounts.id FROM accounts WHERE accounts.multihash = :accountsMultihash LIMIT 1), -1000) AND account_devices.device_id = COALESCE((SELECT devices.id FROM devices WHERE devices.multihash = :devicesMultihash LIMIT 1), -1000)`

	var out AccountDevicesGetProofResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accountsMultihash", accountsMultihash)
		stmt.SetBytes(":devicesMultihash", devicesMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("AccountDevicesGetProof: more than one result return for a single-kind query")
		}

		out.AccountDevicesProof = stmt.ColumnBytes(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountDevicesGetProof: %w", err)
	}

	return out, err
}

func NamedVersionsDelete(conn *sqlite.Conn, namedVersionsObjectID int, namedVersionsAccountID int, namedVersionsDeviceID int, namedVersionsName string) error {
	const query = `DELETE FROM named_versions
WHERE named_versions.object_id = :namedVersionsObjectID
AND named_versions.account_id = :namedVersionsAccountID
AND named_versions.device_id = :namedVersionsDeviceID
AND named_versions.name = :namedVersionsName`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":namedVersionsObjectID", namedVersionsObjectID)
		stmt.SetInt(":namedVersionsAccountID", namedVersionsAccountID)
		stmt.SetInt(":namedVersionsDeviceID", namedVersionsDeviceID)
		stmt.SetText(":namedVersionsName", namedVersionsName)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: NamedVersionsDelete: %w", err)
	}

	return err
}

func NamedVersionsReplace(conn *sqlite.Conn, namedVersionsObjectID int, namedVersionsAccountID int, namedVersionsDeviceID int, namedVersionsName string, namedVersionsVersion string) error {
	const query = `INSERT OR REPLACE INTO named_versions (object_id, account_id, device_id, name, version)
VALUES (:namedVersionsObjectID, :namedVersionsAccountID, :namedVersionsDeviceID, :namedVersionsName, :namedVersionsVersion)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":namedVersionsObjectID", namedVersionsObjectID)
		stmt.SetInt(":namedVersionsAccountID", namedVersionsAccountID)
		stmt.SetInt(":namedVersionsDeviceID", namedVersionsDeviceID)
		stmt.SetText(":namedVersionsName", namedVersionsName)
		stmt.SetText(":namedVersionsVersion", namedVersionsVersion)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: NamedVersionsReplace: %w", err)
	}

	return err
}

type NamedVersionsGetResult struct {
	NamedVersionsVersion string
}

func NamedVersionsGet(conn *sqlite.Conn, namedVersionsObjectID int, namedVersionsAccountID int, namedVersionsDeviceID int, namedVersionsName string) (NamedVersionsGetResult, error) {
	const query = `SELECT named_versions.version
FROM named_versions
WHERE named_versions.object_id = :namedVersionsObjectID
AND named_versions.account_id = :namedVersionsAccountID
AND named_versions.device_id = :namedVersionsDeviceID
AND named_versions.name = :namedVersionsName
LIMIT 1`

	var out NamedVersionsGetResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":namedVersionsObjectID", namedVersionsObjectID)
		stmt.SetInt(":namedVersionsAccountID", namedVersionsAccountID)
		stmt.SetInt(":namedVersionsDeviceID", namedVersionsDeviceID)
		stmt.SetText(":namedVersionsName", namedVersionsName)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("NamedVersionsGet: more than one result return for a single-kind query")
		}

		out.NamedVersionsVersion = stmt.ColumnText(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: NamedVersionsGet: %w", err)
	}

	return out, err
}

type NamedVersionsListByObjectOwnerResult struct {
	AccountsMultihash    []byte
	DevicesMultihash     []byte
	NamedVersionsVersion string
	PermanodeCodec       int
	PermanodeMultihash   []byte
}

func NamedVersionsListByObjectOwner(conn *sqlite.Conn, permanodeOwnersAccountID int) ([]NamedVersionsListByObjectOwnerResult, error) {
	const query = `SELECT accounts.multihash, devices.multihash, named_versions.version, ipfs_blocks.codec AS permanode_codec, ipfs_blocks.multihash AS permanode_multihash
FROM named_versions
INNER JOIN permanode_owners ON permanode_owners.permanode_id = named_versions.object_id
INNER JOIN devices ON devices.id = named_versions.device_id
INNER JOIN accounts ON accounts.id = named_versions.account_id
INNER JOIN ipfs_blocks ON ipfs_blocks.id = named_versions.object_id
WHERE permanode_owners.account_id = :permanodeOwnersAccountID
`

	var out []NamedVersionsListByObjectOwnerResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":permanodeOwnersAccountID", permanodeOwnersAccountID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, NamedVersionsListByObjectOwnerResult{
			AccountsMultihash:    stmt.ColumnBytes(0),
			DevicesMultihash:     stmt.ColumnBytes(1),
			NamedVersionsVersion: stmt.ColumnText(2),
			PermanodeCodec:       stmt.ColumnInt(3),
			PermanodeMultihash:   stmt.ColumnBytes(4),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: NamedVersionsListByObjectOwner: %w", err)
	}

	return out, err
}

type NamedVersionsListAllResult struct {
	AccountsMultihash    []byte
	DevicesMultihash     []byte
	NamedVersionsVersion string
	NamedVersionsName    string
	PermanodeCodec       int
	PermanodeMultihash   []byte
}

func NamedVersionsListAll(conn *sqlite.Conn) ([]NamedVersionsListAllResult, error) {
	const query = `SELECT accounts.multihash, devices.multihash, named_versions.version, named_versions.name, ipfs_blocks.codec AS permanode_codec, ipfs_blocks.multihash AS permanode_multihash
FROM named_versions
INNER JOIN devices ON devices.id = named_versions.device_id
INNER JOIN accounts ON accounts.id = named_versions.account_id
INNER JOIN ipfs_blocks ON ipfs_blocks.id = named_versions.object_id
`

	var out []NamedVersionsListAllResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, NamedVersionsListAllResult{
			AccountsMultihash:    stmt.ColumnBytes(0),
			DevicesMultihash:     stmt.ColumnBytes(1),
			NamedVersionsVersion: stmt.ColumnText(2),
			NamedVersionsName:    stmt.ColumnText(3),
			PermanodeCodec:       stmt.ColumnInt(4),
			PermanodeMultihash:   stmt.ColumnBytes(5),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: NamedVersionsListAll: %w", err)
	}

	return out, err
}

type IPFSBlocksLookupPKResult struct {
	IPFSBlocksID int
}

func IPFSBlocksLookupPK(conn *sqlite.Conn, ipfsBlocksMultihash []byte) (IPFSBlocksLookupPKResult, error) {
	const query = `SELECT ipfs_blocks.id
FROM ipfs_blocks
WHERE ipfs_blocks.multihash = :ipfsBlocksMultihash
`

	var out IPFSBlocksLookupPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ipfsBlocksMultihash", ipfsBlocksMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("IPFSBlocksLookupPK: more than one result return for a single-kind query")
		}

		out.IPFSBlocksID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksLookupPK: %w", err)
	}

	return out, err
}

type IPFSBlocksLookupCIDResult struct {
	IPFSBlocksID        int
	IPFSBlocksCodec     int
	IPFSBlocksMultihash []byte
}

func IPFSBlocksLookupCID(conn *sqlite.Conn, ipfsBlocksID int) (IPFSBlocksLookupCIDResult, error) {
	const query = `SELECT ipfs_blocks.id, ipfs_blocks.codec, ipfs_blocks.multihash
FROM ipfs_blocks
WHERE ipfs_blocks.id = :ipfsBlocksID
`

	var out IPFSBlocksLookupCIDResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":ipfsBlocksID", ipfsBlocksID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("IPFSBlocksLookupCID: more than one result return for a single-kind query")
		}

		out.IPFSBlocksID = stmt.ColumnInt(0)
		out.IPFSBlocksCodec = stmt.ColumnInt(1)
		out.IPFSBlocksMultihash = stmt.ColumnBytes(2)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksLookupCID: %w", err)
	}

	return out, err
}

func IPFSBlocksInsert(conn *sqlite.Conn, ipfsBlocksID int, ipfsBlocksMultihash []byte, ipfsBlocksCodec int, ipfsBlocksData []byte, ipfsBlocksSize int, ipfsBlocksPending int) error {
	const query = `INSERT INTO ipfs_blocks (id, multihash, codec, data, size, pending)
VALUES (:ipfsBlocksID, :ipfsBlocksMultihash, :ipfsBlocksCodec, :ipfsBlocksData, :ipfsBlocksSize, :ipfsBlocksPending)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":ipfsBlocksID", ipfsBlocksID)
		stmt.SetBytes(":ipfsBlocksMultihash", ipfsBlocksMultihash)
		stmt.SetInt(":ipfsBlocksCodec", ipfsBlocksCodec)
		stmt.SetBytes(":ipfsBlocksData", ipfsBlocksData)
		stmt.SetInt(":ipfsBlocksSize", ipfsBlocksSize)
		stmt.SetInt(":ipfsBlocksPending", ipfsBlocksPending)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksInsert: %w", err)
	}

	return err
}

type IPFSBlocksUpsertResult struct {
	IPFSBlocksID int
}

func IPFSBlocksUpsert(conn *sqlite.Conn, ipfsBlocksMultihash []byte, ipfsBlocksCodec int, ipfsBlocksData []byte, ipfsBlocksSize int, ipfsBlocksPending int) (IPFSBlocksUpsertResult, error) {
	const query = `INSERT INTO ipfs_blocks (multihash, codec, data, size, pending)
VALUES (:ipfsBlocksMultihash, :ipfsBlocksCodec, :ipfsBlocksData, :ipfsBlocksSize, :ipfsBlocksPending)
ON CONFLICT (multihash)
DO UPDATE SET codec = excluded.codec, data = excluded.data, size = excluded.size, pending = excluded.pending
WHERE pending = 1 AND excluded.pending = 0
RETURNING ipfs_blocks.id`

	var out IPFSBlocksUpsertResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ipfsBlocksMultihash", ipfsBlocksMultihash)
		stmt.SetInt(":ipfsBlocksCodec", ipfsBlocksCodec)
		stmt.SetBytes(":ipfsBlocksData", ipfsBlocksData)
		stmt.SetInt(":ipfsBlocksSize", ipfsBlocksSize)
		stmt.SetInt(":ipfsBlocksPending", ipfsBlocksPending)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("IPFSBlocksUpsert: more than one result return for a single-kind query")
		}

		out.IPFSBlocksID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksUpsert: %w", err)
	}

	return out, err
}

type IPFSBlocksListValidResult struct {
	IPFSBlocksID        int
	IPFSBlocksMultihash []byte
	IPFSBlocksCodec     int
}

func IPFSBlocksListValid(conn *sqlite.Conn) ([]IPFSBlocksListValidResult, error) {
	const query = `SELECT ipfs_blocks.id, ipfs_blocks.multihash, ipfs_blocks.codec
FROM ipfs_blocks
WHERE ipfs_blocks.pending = 0`

	var out []IPFSBlocksListValidResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, IPFSBlocksListValidResult{
			IPFSBlocksID:        stmt.ColumnInt(0),
			IPFSBlocksMultihash: stmt.ColumnBytes(1),
			IPFSBlocksCodec:     stmt.ColumnInt(2),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksListValid: %w", err)
	}

	return out, err
}

type IPFSBlocksHasResult struct {
	Has int
}

func IPFSBlocksHas(conn *sqlite.Conn, ipfsBlocksMultihash []byte) (IPFSBlocksHasResult, error) {
	const query = `SELECT 1 AS has
FROM ipfs_blocks
WHERE ipfs_blocks.multihash = :ipfsBlocksMultihash
AND ipfs_blocks.pending = 0`

	var out IPFSBlocksHasResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ipfsBlocksMultihash", ipfsBlocksMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("IPFSBlocksHas: more than one result return for a single-kind query")
		}

		out.Has = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksHas: %w", err)
	}

	return out, err
}

type IPFSBlocksGetResult struct {
	IPFSBlocksID        int
	IPFSBlocksMultihash []byte
	IPFSBlocksCodec     int
	IPFSBlocksData      []byte
	IPFSBlocksSize      int
}

func IPFSBlocksGet(conn *sqlite.Conn, ipfsBlocksMultihash []byte) (IPFSBlocksGetResult, error) {
	const query = `SELECT ipfs_blocks.id, ipfs_blocks.multihash, ipfs_blocks.codec, ipfs_blocks.data, ipfs_blocks.size
FROM ipfs_blocks
WHERE ipfs_blocks.multihash = :ipfsBlocksMultihash AND ipfs_blocks.pending = 0`

	var out IPFSBlocksGetResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ipfsBlocksMultihash", ipfsBlocksMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("IPFSBlocksGet: more than one result return for a single-kind query")
		}

		out.IPFSBlocksID = stmt.ColumnInt(0)
		out.IPFSBlocksMultihash = stmt.ColumnBytes(1)
		out.IPFSBlocksCodec = stmt.ColumnInt(2)
		out.IPFSBlocksData = stmt.ColumnBytes(3)
		out.IPFSBlocksSize = stmt.ColumnInt(4)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksGet: %w", err)
	}

	return out, err
}

type IPFSBlocksGetSizeResult struct {
	IPFSBlocksID   int
	IPFSBlocksSize int
}

func IPFSBlocksGetSize(conn *sqlite.Conn, ipfsBlocksMultihash []byte) (IPFSBlocksGetSizeResult, error) {
	const query = `SELECT ipfs_blocks.id, ipfs_blocks.size
FROM ipfs_blocks
WHERE ipfs_blocks.multihash = :ipfsBlocksMultihash AND ipfs_blocks.pending = 0`

	var out IPFSBlocksGetSizeResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ipfsBlocksMultihash", ipfsBlocksMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("IPFSBlocksGetSize: more than one result return for a single-kind query")
		}

		out.IPFSBlocksID = stmt.ColumnInt(0)
		out.IPFSBlocksSize = stmt.ColumnInt(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksGetSize: %w", err)
	}

	return out, err
}

func IPFSBlocksDelete(conn *sqlite.Conn, ipfsBlocksMultihash []byte) error {
	const query = `DELETE FROM ipfs_blocks
WHERE ipfs_blocks.multihash = :ipfsBlocksMultihash`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ipfsBlocksMultihash", ipfsBlocksMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksDelete: %w", err)
	}

	return err
}

func IPFSBlocksDeleteByID(conn *sqlite.Conn, ipfsBlocksID int) error {
	const query = `DELETE FROM ipfs_blocks
WHERE ipfs_blocks.id = :ipfsBlocksID`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":ipfsBlocksID", ipfsBlocksID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksDeleteByID: %w", err)
	}

	return err
}

type IPFSBlocksGetHashResult struct {
	IPFSBlocksCodec     int
	IPFSBlocksMultihash []byte
}

func IPFSBlocksGetHash(conn *sqlite.Conn, ipfsBlocksID int) (IPFSBlocksGetHashResult, error) {
	const query = `SELECT ipfs_blocks.codec, ipfs_blocks.multihash
FROM ipfs_blocks
WHERE ipfs_blocks.id = :ipfsBlocksID
LIMIT 1`

	var out IPFSBlocksGetHashResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":ipfsBlocksID", ipfsBlocksID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("IPFSBlocksGetHash: more than one result return for a single-kind query")
		}

		out.IPFSBlocksCodec = stmt.ColumnInt(0)
		out.IPFSBlocksMultihash = stmt.ColumnBytes(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksGetHash: %w", err)
	}

	return out, err
}

func PermanodesInsertOrIgnore(conn *sqlite.Conn, permanodesType string, permanodesID int, permanodesCreateTime int) error {
	const query = `INSERT OR IGNORE INTO permanodes (type, id, create_time)
VALUES (:permanodesType, :permanodesID, :permanodesCreateTime)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":permanodesType", permanodesType)
		stmt.SetInt(":permanodesID", permanodesID)
		stmt.SetInt(":permanodesCreateTime", permanodesCreateTime)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: PermanodesInsertOrIgnore: %w", err)
	}

	return err
}

func PermanodeOwnersInsertOrIgnore(conn *sqlite.Conn, permanodeOwnersAccountID int, permanodeOwnersPermanodeID int) error {
	const query = `INSERT OR IGNORE INTO permanode_owners (account_id, permanode_id)
VALUES (:permanodeOwnersAccountID, :permanodeOwnersPermanodeID)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":permanodeOwnersAccountID", permanodeOwnersAccountID)
		stmt.SetInt(":permanodeOwnersPermanodeID", permanodeOwnersPermanodeID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: PermanodeOwnersInsertOrIgnore: %w", err)
	}

	return err
}

type PermanodeOwnersGetOneResult struct {
	AccountsMultihash []byte
}

func PermanodeOwnersGetOne(conn *sqlite.Conn, permanodeOwnersPermanodeID int) (PermanodeOwnersGetOneResult, error) {
	const query = `SELECT accounts.multihash
FROM permanode_owners
JOIN accounts ON permanode_owners.account_id = accounts.id
WHERE permanode_owners.permanode_id = :permanodeOwnersPermanodeID
LIMIT 1`

	var out PermanodeOwnersGetOneResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":permanodeOwnersPermanodeID", permanodeOwnersPermanodeID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("PermanodeOwnersGetOne: more than one result return for a single-kind query")
		}

		out.AccountsMultihash = stmt.ColumnBytes(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: PermanodeOwnersGetOne: %w", err)
	}

	return out, err
}

type PermanodesListWithVersionsByTypeResult struct {
	PermanodesID             int
	PermanodeOwnersAccountID int
	AccountsMultihash        []byte
	PermanodeCodec           int
	PermanodeMultihash       []byte
	PermanodesCreateTime     int
}

func PermanodesListWithVersionsByType(conn *sqlite.Conn, permanodesType string) ([]PermanodesListWithVersionsByTypeResult, error) {
	const query = `SELECT permanodes.id, permanode_owners.account_id, accounts.multihash, ipfs_blocks.codec AS permanode_codec, ipfs_blocks.multihash AS permanode_multihash, permanodes.create_time
FROM permanodes
JOIN ipfs_blocks ON ipfs_blocks.id = permanodes.id
JOIN permanode_owners ON permanode_owners.permanode_id = permanodes.id
JOIN accounts ON accounts.id = permanode_owners.account_id
WHERE permanodes.type = :permanodesType
AND permanodes.id IN (SELECT DISTINCT named_versions.object_id FROM named_versions)`

	var out []PermanodesListWithVersionsByTypeResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":permanodesType", permanodesType)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, PermanodesListWithVersionsByTypeResult{
			PermanodesID:             stmt.ColumnInt(0),
			PermanodeOwnersAccountID: stmt.ColumnInt(1),
			AccountsMultihash:        stmt.ColumnBytes(2),
			PermanodeCodec:           stmt.ColumnInt(3),
			PermanodeMultihash:       stmt.ColumnBytes(4),
			PermanodesCreateTime:     stmt.ColumnInt(5),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: PermanodesListWithVersionsByType: %w", err)
	}

	return out, err
}

type PermanodesListByTypeResult struct {
	PermanodesID             int
	PermanodeOwnersAccountID int
	AccountsMultihash        []byte
	PermanodeCodec           int
	PermanodeMultihash       []byte
	PermanodesCreateTime     int
}

func PermanodesListByType(conn *sqlite.Conn, permanodesType string) ([]PermanodesListByTypeResult, error) {
	const query = `SELECT permanodes.id, permanode_owners.account_id, accounts.multihash, ipfs_blocks.codec AS permanode_codec, ipfs_blocks.multihash AS permanode_multihash, permanodes.create_time
FROM permanodes
JOIN ipfs_blocks ON ipfs_blocks.id = permanodes.id
JOIN permanode_owners ON permanode_owners.permanode_id = permanodes.id JOIN accounts ON accounts.id = permanode_owners.account_id WHERE permanodes.type = :permanodesType`

	var out []PermanodesListByTypeResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":permanodesType", permanodesType)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, PermanodesListByTypeResult{
			PermanodesID:             stmt.ColumnInt(0),
			PermanodeOwnersAccountID: stmt.ColumnInt(1),
			AccountsMultihash:        stmt.ColumnBytes(2),
			PermanodeCodec:           stmt.ColumnInt(3),
			PermanodeMultihash:       stmt.ColumnBytes(4),
			PermanodesCreateTime:     stmt.ColumnInt(5),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: PermanodesListByType: %w", err)
	}

	return out, err
}

func ChangesInsertOrIgnore(conn *sqlite.Conn, changesID int, changesPermanodeID int, changesKind string, changesLamportTime int, changesCreateTime int) error {
	const query = `INSERT OR IGNORE INTO changes (id, permanode_id, kind, lamport_time, create_time)
VALUES (:changesID, :changesPermanodeID, :changesKind, :changesLamportTime, :changesCreateTime)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":changesID", changesID)
		stmt.SetInt(":changesPermanodeID", changesPermanodeID)
		stmt.SetText(":changesKind", changesKind)
		stmt.SetInt(":changesLamportTime", changesLamportTime)
		stmt.SetInt(":changesCreateTime", changesCreateTime)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ChangesInsertOrIgnore: %w", err)
	}

	return err
}

type ChangesGetBaseResult struct {
	Count    int
	MaxClock int
}

func ChangesGetBase(conn *sqlite.Conn, jsonHeads string, changesPermanodeID int) (ChangesGetBaseResult, error) {
	const query = `SELECT COUNT(id) AS count, MAX(lamport_time) AS max_clock
FROM changes
WHERE changes.id IN (SELECT value FROM json_each( :jsonHeads ))
AND changes.permanode_id = :changesPermanodeID`

	var out ChangesGetBaseResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":jsonHeads", jsonHeads)
		stmt.SetInt(":changesPermanodeID", changesPermanodeID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("ChangesGetBase: more than one result return for a single-kind query")
		}

		out.Count = stmt.ColumnInt(0)
		out.MaxClock = stmt.ColumnInt(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ChangesGetBase: %w", err)
	}

	return out, err
}

type ChangesGetWithAuthorsResult struct {
	ChangesID              int
	IPFSBlocksCodec        int
	IPFSBlocksMultihash    []byte
	ChangesPermanodeID     int
	ChangesKind            string
	ChangesLamportTime     int
	ChangesCreateTime      int
	AccountsMultihash      []byte
	DevicesMultihash       []byte
	ChangeAuthorsAccountID int
	ChangeAuthorsDeviceID  int
}

func ChangesGetWithAuthors(conn *sqlite.Conn, changesID int) ([]ChangesGetWithAuthorsResult, error) {
	const query = `SELECT changes.id, ipfs_blocks.codec, ipfs_blocks.multihash, changes.permanode_id, changes.kind, changes.lamport_time, changes.create_time, accounts.multihash, devices.multihash, change_authors.account_id, change_authors.device_id
FROM changes
JOIN change_authors ON change_authors.change_id = changes.id
JOIN accounts ON accounts.id = change_authors.account_id
JOIN devices ON devices.id = change_authors.device_id
JOIN ipfs_blocks ON ipfs_blocks.id = changes.permanode_id
WHERE changes.id = :changesID`

	var out []ChangesGetWithAuthorsResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":changesID", changesID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, ChangesGetWithAuthorsResult{
			ChangesID:              stmt.ColumnInt(0),
			IPFSBlocksCodec:        stmt.ColumnInt(1),
			IPFSBlocksMultihash:    stmt.ColumnBytes(2),
			ChangesPermanodeID:     stmt.ColumnInt(3),
			ChangesKind:            stmt.ColumnText(4),
			ChangesLamportTime:     stmt.ColumnInt(5),
			ChangesCreateTime:      stmt.ColumnInt(6),
			AccountsMultihash:      stmt.ColumnBytes(7),
			DevicesMultihash:       stmt.ColumnBytes(8),
			ChangeAuthorsAccountID: stmt.ColumnInt(9),
			ChangeAuthorsDeviceID:  stmt.ColumnInt(10),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ChangesGetWithAuthors: %w", err)
	}

	return out, err
}

type ChangesGetParentsResult struct {
	ChangeDepsParent    int
	ChangeDepsChild     int
	IPFSBlocksCodec     int
	IPFSBlocksMultihash []byte
}

func ChangesGetParents(conn *sqlite.Conn, changeDepsChild int) ([]ChangesGetParentsResult, error) {
	const query = `SELECT change_deps.parent, change_deps.child, ipfs_blocks.codec, ipfs_blocks.multihash
FROM change_deps
LEFT OUTER JOIN ipfs_blocks ON ipfs_blocks.id = change_deps.parent
WHERE change_deps.child = :changeDepsChild
ORDER BY ipfs_blocks.multihash`

	var out []ChangesGetParentsResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":changeDepsChild", changeDepsChild)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, ChangesGetParentsResult{
			ChangeDepsParent:    stmt.ColumnInt(0),
			ChangeDepsChild:     stmt.ColumnInt(1),
			IPFSBlocksCodec:     stmt.ColumnInt(2),
			IPFSBlocksMultihash: stmt.ColumnBytes(3),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ChangesGetParents: %w", err)
	}

	return out, err
}

func ChangesInsertParent(conn *sqlite.Conn, changeDepsChild int, changeDepsParent int) error {
	const query = `INSERT INTO change_deps (child, parent)
VALUES (:changeDepsChild, :changeDepsParent)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":changeDepsChild", changeDepsChild)
		stmt.SetInt(":changeDepsParent", changeDepsParent)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ChangesInsertParent: %w", err)
	}

	return err
}

func ChangeAuthorsInsertOrIgnore(conn *sqlite.Conn, changeAuthorsChangeID int, changeAuthorsAccountID int, changeAuthorsDeviceID int) error {
	const query = `INSERT OR IGNORE INTO change_authors (change_id, account_id, device_id)
VALUES (:changeAuthorsChangeID, :changeAuthorsAccountID, :changeAuthorsDeviceID)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":changeAuthorsChangeID", changeAuthorsChangeID)
		stmt.SetInt(":changeAuthorsAccountID", changeAuthorsAccountID)
		stmt.SetInt(":changeAuthorsDeviceID", changeAuthorsDeviceID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ChangeAuthorsInsertOrIgnore: %w", err)
	}

	return err
}

type ChangesAllocateIDResult struct {
	Seq int
}

func ChangesAllocateID(conn *sqlite.Conn) (ChangesAllocateIDResult, error) {
	const query = `UPDATE sqlite_sequence
SET seq = seq + 1
WHERE name = 'ipfs_blocks'
RETURNING seq`

	var out ChangesAllocateIDResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("ChangesAllocateID: more than one result return for a single-kind query")
		}

		out.Seq = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ChangesAllocateID: %w", err)
	}

	return out, err
}

func ChangesDeleteByID(conn *sqlite.Conn, changesID int) error {
	const query = `DELETE FROM changes
WHERE changes.id = :changesID`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":changesID", changesID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ChangesDeleteByID: %w", err)
	}

	return err
}

type DatomsAttrInsertResult struct {
	DatomAttrsID int
}

func DatomsAttrInsert(conn *sqlite.Conn, datomAttrsAttr string) (DatomsAttrInsertResult, error) {
	const query = `INSERT INTO datom_attrs (attr)
VALUES (:datomAttrsAttr)
RETURNING datom_attrs.id`

	var out DatomsAttrInsertResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":datomAttrsAttr", datomAttrsAttr)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("DatomsAttrInsert: more than one result return for a single-kind query")
		}

		out.DatomAttrsID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DatomsAttrInsert: %w", err)
	}

	return out, err
}

type DatomsAttrLookupResult struct {
	DatomAttrsID int
}

func DatomsAttrLookup(conn *sqlite.Conn, datomAttrsAttr string) (DatomsAttrLookupResult, error) {
	const query = `SELECT datom_attrs.id
FROM datom_attrs
WHERE datom_attrs.attr = :datomAttrsAttr LIMIT 1`

	var out DatomsAttrLookupResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":datomAttrsAttr", datomAttrsAttr)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("DatomsAttrLookup: more than one result return for a single-kind query")
		}

		out.DatomAttrsID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DatomsAttrLookup: %w", err)
	}

	return out, err
}

type DatomsMaxSeqResult struct {
	Max int
}

func DatomsMaxSeq(conn *sqlite.Conn, datomsPermanode int, datomsChange int) (DatomsMaxSeqResult, error) {
	const query = `SELECT MAX(datoms.seq) AS max
FROM datoms
WHERE datoms.permanode = :datomsPermanode
AND datoms.change = :datomsChange
LIMIT 1`

	var out DatomsMaxSeqResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":datomsPermanode", datomsPermanode)
		stmt.SetInt(":datomsChange", datomsChange)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("DatomsMaxSeq: more than one result return for a single-kind query")
		}

		out.Max = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DatomsMaxSeq: %w", err)
	}

	return out, err
}

func DatomsDelete(conn *sqlite.Conn, datomsPermanode int, datomsEntity []byte, datomsChange int, datomsAttr int) error {
	const query = `DELETE FROM datoms
WHERE datoms.permanode = :datomsPermanode
AND datoms.entity = :datomsEntity
AND datoms.change = :datomsChange
AND datoms.attr = :datomsAttr`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":datomsPermanode", datomsPermanode)
		stmt.SetBytes(":datomsEntity", datomsEntity)
		stmt.SetInt(":datomsChange", datomsChange)
		stmt.SetInt(":datomsAttr", datomsAttr)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DatomsDelete: %w", err)
	}

	return err
}
