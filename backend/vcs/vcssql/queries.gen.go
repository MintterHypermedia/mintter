// Code generated by sqlitegen. DO NOT EDIT.

package vcssql

import (
	"errors"
	"fmt"

	"crawshaw.io/sqlite"
	"mintter/backend/db/sqlitegen"
)

var _ = errors.New

func WorkingCopyReplace(conn *sqlite.Conn, workingCopyObjectID int, workingCopyName string, workingCopyVersion string, workingCopyData []byte, workingCopyCreateTime int, workingCopyUpdateTime int) error {
	const query = `INSERT OR REPLACE INTO working_copy (object_id, name, version, data, create_time, update_time)
VALUES (:workingCopyObjectID, :workingCopyName, :workingCopyVersion, :workingCopyData, :workingCopyCreateTime, :workingCopyUpdateTime)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":workingCopyObjectID", workingCopyObjectID)
		stmt.SetText(":workingCopyName", workingCopyName)
		stmt.SetText(":workingCopyVersion", workingCopyVersion)
		stmt.SetBytes(":workingCopyData", workingCopyData)
		stmt.SetInt(":workingCopyCreateTime", workingCopyCreateTime)
		stmt.SetInt(":workingCopyUpdateTime", workingCopyUpdateTime)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: WorkingCopyReplace: %w", err)
	}

	return err
}

type WorkingCopyGetResult struct {
	WorkingCopyData       []byte
	WorkingCopyCreateTime int
	WorkingCopyUpdateTime int
	WorkingCopyVersion    string
}

func WorkingCopyGet(conn *sqlite.Conn, workingCopyObjectID int, workingCopyName string) (WorkingCopyGetResult, error) {
	const query = `SELECT working_copy.data, working_copy.create_time, working_copy.update_time, working_copy.version
FROM working_copy
WHERE working_copy.object_id = :workingCopyObjectID
AND working_copy.name = :workingCopyName
LIMIT 1`

	var out WorkingCopyGetResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":workingCopyObjectID", workingCopyObjectID)
		stmt.SetText(":workingCopyName", workingCopyName)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("WorkingCopyGet: more than one result return for a single-kind query")
		}

		out.WorkingCopyData = stmt.ColumnBytes(0)
		out.WorkingCopyCreateTime = stmt.ColumnInt(1)
		out.WorkingCopyUpdateTime = stmt.ColumnInt(2)
		out.WorkingCopyVersion = stmt.ColumnText(3)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: WorkingCopyGet: %w", err)
	}

	return out, err
}

func WorkingCopyDelete(conn *sqlite.Conn, workingCopyObjectID int, workingCopyName string) error {
	const query = `DELETE FROM working_copy
WHERE working_copy.object_id = :workingCopyObjectID
AND working_copy.name = :workingCopyName`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":workingCopyObjectID", workingCopyObjectID)
		stmt.SetText(":workingCopyName", workingCopyName)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: WorkingCopyDelete: %w", err)
	}

	return err
}

type AccountsLookupPKResult struct {
	AccountsID int
}

func AccountsLookupPK(conn *sqlite.Conn, accountsMultihash []byte, accountsCodec int) (AccountsLookupPKResult, error) {
	const query = `SELECT accounts.id
FROM accounts
WHERE accounts.multihash = :accountsMultihash AND accounts.codec = :accountsCodec`

	var out AccountsLookupPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accountsMultihash", accountsMultihash)
		stmt.SetInt(":accountsCodec", accountsCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("AccountsLookupPK: more than one result return for a single-kind query")
		}

		out.AccountsID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsLookupPK: %w", err)
	}

	return out, err
}

type ObjectsLookupPKResult struct {
	ObjectsID int
}

func ObjectsLookupPK(conn *sqlite.Conn, objectsMultihash []byte, objectsCodec int) (ObjectsLookupPKResult, error) {
	const query = `SELECT objects.id
FROM objects
WHERE objects.multihash = :objectsMultihash AND objects.codec = :objectsCodec`

	var out ObjectsLookupPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":objectsMultihash", objectsMultihash)
		stmt.SetInt(":objectsCodec", objectsCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("ObjectsLookupPK: more than one result return for a single-kind query")
		}

		out.ObjectsID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ObjectsLookupPK: %w", err)
	}

	return out, err
}

type DevicesLookupPKResult struct {
	DevicesID int
}

func DevicesLookupPK(conn *sqlite.Conn, devicesMultihash []byte, devicesCodec int) (DevicesLookupPKResult, error) {
	const query = `SELECT devices.id
FROM devices
WHERE devices.multihash = :devicesMultihash AND devices.codec = :devicesCodec`

	var out DevicesLookupPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":devicesMultihash", devicesMultihash)
		stmt.SetInt(":devicesCodec", devicesCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("DevicesLookupPK: more than one result return for a single-kind query")
		}

		out.DevicesID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DevicesLookupPK: %w", err)
	}

	return out, err
}

type AccountsInsertPKResult struct {
	AccountsID int
}

func AccountsInsertPK(conn *sqlite.Conn, accountsMultihash []byte, accountsCodec int) (AccountsInsertPKResult, error) {
	const query = `INSERT INTO accounts (multihash, codec)
VALUES (:accountsMultihash, :accountsCodec) RETURNING accounts.id`

	var out AccountsInsertPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accountsMultihash", accountsMultihash)
		stmt.SetInt(":accountsCodec", accountsCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("AccountsInsertPK: more than one result return for a single-kind query")
		}

		out.AccountsID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsInsertPK: %w", err)
	}

	return out, err
}

type AccountsGetForDeviceResult struct {
	AccountsID        int
	AccountsMultihash []byte
	AccountsCodec     int
}

func AccountsGetForDevice(conn *sqlite.Conn, devicesMultihash []byte) (AccountsGetForDeviceResult, error) {
	const query = `SELECT accounts.id, accounts.multihash, accounts.codec
FROM accounts
WHERE accounts.id = COALESCE((SELECT devices.account_id FROM devices WHERE devices.multihash = :devicesMultihash LIMIT 1), -1000)`

	var out AccountsGetForDeviceResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":devicesMultihash", devicesMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("AccountsGetForDevice: more than one result return for a single-kind query")
		}

		out.AccountsID = stmt.ColumnInt(0)
		out.AccountsMultihash = stmt.ColumnBytes(1)
		out.AccountsCodec = stmt.ColumnInt(2)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsGetForDevice: %w", err)
	}

	return out, err
}

type AccountsListResult struct {
	AccountsCodec     int
	AccountsMultihash []byte
	AccountsAlias     string
	AccountsEmail     string
	AccountsBio       string
}

func AccountsList(conn *sqlite.Conn, ownAccountMultihash []byte) ([]AccountsListResult, error) {
	const query = `SELECT accounts.codec, accounts.multihash, accounts.alias, accounts.email, accounts.bio
FROM accounts
WHERE accounts.multihash != :ownAccountMultihash`

	var out []AccountsListResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ownAccountMultihash", ownAccountMultihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, AccountsListResult{
			AccountsCodec:     stmt.ColumnInt(0),
			AccountsMultihash: stmt.ColumnBytes(1),
			AccountsAlias:     stmt.ColumnText(2),
			AccountsEmail:     stmt.ColumnText(3),
			AccountsBio:       stmt.ColumnText(4),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: AccountsList: %w", err)
	}

	return out, err
}

type ObjectsInsertPKResult struct {
	ObjectsID int
}

func ObjectsInsertPK(conn *sqlite.Conn, objectsMultihash []byte, objectsCodec int) (ObjectsInsertPKResult, error) {
	const query = `INSERT INTO objects (multihash, codec)
VALUES (:objectsMultihash, :objectsCodec) RETURNING objects.id`

	var out ObjectsInsertPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":objectsMultihash", objectsMultihash)
		stmt.SetInt(":objectsCodec", objectsCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("ObjectsInsertPK: more than one result return for a single-kind query")
		}

		out.ObjectsID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ObjectsInsertPK: %w", err)
	}

	return out, err
}

type DevicesInsertPKResult struct {
	DevicesID int
}

func DevicesInsertPK(conn *sqlite.Conn, devicesMultihash []byte, devicesCodec int) (DevicesInsertPKResult, error) {
	const query = `INSERT INTO devices (multihash, codec)
VALUES (:devicesMultihash, :devicesCodec) RETURNING devices.id`

	var out DevicesInsertPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":devicesMultihash", devicesMultihash)
		stmt.SetInt(":devicesCodec", devicesCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("DevicesInsertPK: more than one result return for a single-kind query")
		}

		out.DevicesID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DevicesInsertPK: %w", err)
	}

	return out, err
}

func DevicesUpdateAccount(conn *sqlite.Conn, devicesAccountID int, devicesID int) error {
	const query = `UPDATE devices
SET account_id = :devicesAccountID
WHERE id = :devicesID`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":devicesAccountID", devicesAccountID)
		stmt.SetInt(":devicesID", devicesID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DevicesUpdateAccount: %w", err)
	}

	return err
}

type DevicesListResult struct {
	DevicesCodec      int
	DevicesMultihash  []byte
	AccountsCodec     int
	AccountsMultihash []byte
}

func DevicesList(conn *sqlite.Conn) ([]DevicesListResult, error) {
	const query = `SELECT devices.codec, devices.multihash, accounts.codec, accounts.multihash
FROM devices
JOIN accounts ON accounts.id = devices.account_id`

	var out []DevicesListResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, DevicesListResult{
			DevicesCodec:      stmt.ColumnInt(0),
			DevicesMultihash:  stmt.ColumnBytes(1),
			AccountsCodec:     stmt.ColumnInt(2),
			AccountsMultihash: stmt.ColumnBytes(3),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DevicesList: %w", err)
	}

	return out, err
}

func ObjectsInsertOrIgnore(conn *sqlite.Conn, ipfsBlocksID int, objectsMultihash []byte, objectsCodec int, objectsAccountID int) error {
	const query = `INSERT OR IGNORE INTO objects (id, multihash, codec, account_id)
VALUES (:ipfsBlocksID, :objectsMultihash, :objectsCodec, :objectsAccountID)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":ipfsBlocksID", ipfsBlocksID)
		stmt.SetBytes(":objectsMultihash", objectsMultihash)
		stmt.SetInt(":objectsCodec", objectsCodec)
		stmt.SetInt(":objectsAccountID", objectsAccountID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ObjectsInsertOrIgnore: %w", err)
	}

	return err
}

func ObjectsDelete(conn *sqlite.Conn, objectsMultihash []byte, objectsCodec int) error {
	const query = `DELETE FROM objects
WHERE objects.multihash = :objectsMultihash AND objects.codec = :objectsCodec`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":objectsMultihash", objectsMultihash)
		stmt.SetInt(":objectsCodec", objectsCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: ObjectsDelete: %w", err)
	}

	return err
}

func NamedVersionsReplace(conn *sqlite.Conn, namedVersionsObjectID int, namedVersionsAccountID int, namedVersionsDeviceID int, namedVersionsName string, namedVersionsVersion string) error {
	const query = `INSERT OR REPLACE INTO named_versions (object_id, account_id, device_id, name, version)
VALUES (:namedVersionsObjectID, :namedVersionsAccountID, :namedVersionsDeviceID, :namedVersionsName, :namedVersionsVersion)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":namedVersionsObjectID", namedVersionsObjectID)
		stmt.SetInt(":namedVersionsAccountID", namedVersionsAccountID)
		stmt.SetInt(":namedVersionsDeviceID", namedVersionsDeviceID)
		stmt.SetText(":namedVersionsName", namedVersionsName)
		stmt.SetText(":namedVersionsVersion", namedVersionsVersion)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: NamedVersionsReplace: %w", err)
	}

	return err
}

type NamedVersionsGetResult struct {
	NamedVersionsVersion string
}

func NamedVersionsGet(conn *sqlite.Conn, namedVersionsObjectID int, namedVersionsAccountID int, namedVersionsDeviceID int, namedVersionsName string) (NamedVersionsGetResult, error) {
	const query = `SELECT named_versions.version
FROM named_versions
WHERE named_versions.object_id = :namedVersionsObjectID
AND named_versions.account_id = :namedVersionsAccountID
AND named_versions.device_id = :namedVersionsDeviceID
AND named_versions.name = :namedVersionsName
LIMIT 1`

	var out NamedVersionsGetResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":namedVersionsObjectID", namedVersionsObjectID)
		stmt.SetInt(":namedVersionsAccountID", namedVersionsAccountID)
		stmt.SetInt(":namedVersionsDeviceID", namedVersionsDeviceID)
		stmt.SetText(":namedVersionsName", namedVersionsName)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("NamedVersionsGet: more than one result return for a single-kind query")
		}

		out.NamedVersionsVersion = stmt.ColumnText(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: NamedVersionsGet: %w", err)
	}

	return out, err
}

type IPFSBlocksLookupPKResult struct {
	IPFSBlocksID int
}

func IPFSBlocksLookupPK(conn *sqlite.Conn, ipfsBlocksMultihash []byte, ipfsBlocksCodec int) (IPFSBlocksLookupPKResult, error) {
	const query = `SELECT ipfs_blocks.id
FROM ipfs_blocks
WHERE ipfs_blocks.multihash = :ipfsBlocksMultihash
AND ipfs_blocks.codec = :ipfsBlocksCodec
`

	var out IPFSBlocksLookupPKResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":ipfsBlocksMultihash", ipfsBlocksMultihash)
		stmt.SetInt(":ipfsBlocksCodec", ipfsBlocksCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("IPFSBlocksLookupPK: more than one result return for a single-kind query")
		}

		out.IPFSBlocksID = stmt.ColumnInt(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: IPFSBlocksLookupPK: %w", err)
	}

	return out, err
}

func DraftsInsert(conn *sqlite.Conn, objectsMultihash []byte, objectsCodec int, draftsTitle string, draftsSubtitle string, draftsCreateTime int, draftsUpdateTime int) error {
	const query = `INSERT INTO drafts (id, title, subtitle, create_time, update_time)
VALUES (COALESCE((SELECT objects.id FROM objects WHERE objects.multihash = :objectsMultihash AND objects.codec = :objectsCodec LIMIT 1), -1000), :draftsTitle, :draftsSubtitle, :draftsCreateTime, :draftsUpdateTime)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":objectsMultihash", objectsMultihash)
		stmt.SetInt(":objectsCodec", objectsCodec)
		stmt.SetText(":draftsTitle", draftsTitle)
		stmt.SetText(":draftsSubtitle", draftsSubtitle)
		stmt.SetInt(":draftsCreateTime", draftsCreateTime)
		stmt.SetInt(":draftsUpdateTime", draftsUpdateTime)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DraftsInsert: %w", err)
	}

	return err
}

func DraftsUpdate(conn *sqlite.Conn, draftsTitle string, draftsSubtitle string, draftsUpdateTime int, objectsMultihash []byte, objectsCodec int) error {
	const query = `UPDATE drafts
SET (title, subtitle, update_time) = (:draftsTitle, :draftsSubtitle, :draftsUpdateTime)
WHERE drafts.id = COALESCE((SELECT objects.id FROM objects WHERE objects.multihash = :objectsMultihash AND objects.codec = :objectsCodec LIMIT 1), -1000)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":draftsTitle", draftsTitle)
		stmt.SetText(":draftsSubtitle", draftsSubtitle)
		stmt.SetInt(":draftsUpdateTime", draftsUpdateTime)
		stmt.SetBytes(":objectsMultihash", objectsMultihash)
		stmt.SetInt(":objectsCodec", objectsCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DraftsUpdate: %w", err)
	}

	return err
}

type DraftsListResult struct {
	ObjectsMultihash []byte
	ObjectsCodec     int
	DraftsTitle      string
	DraftsSubtitle   string
	DraftsCreateTime int
	DraftsUpdateTime int
}

func DraftsList(conn *sqlite.Conn) ([]DraftsListResult, error) {
	const query = `SELECT objects.multihash, objects.codec, drafts.title, drafts.subtitle, drafts.create_time, drafts.update_time
FROM drafts
JOIN objects ON objects.id = drafts.id
`

	var out []DraftsListResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, DraftsListResult{
			ObjectsMultihash: stmt.ColumnBytes(0),
			ObjectsCodec:     stmt.ColumnInt(1),
			DraftsTitle:      stmt.ColumnText(2),
			DraftsSubtitle:   stmt.ColumnText(3),
			DraftsCreateTime: stmt.ColumnInt(4),
			DraftsUpdateTime: stmt.ColumnInt(5),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DraftsList: %w", err)
	}

	return out, err
}

func DraftsDelete(conn *sqlite.Conn, objectsMultihash []byte, objectsCodec int) error {
	const query = `DELETE FROM drafts
WHERE drafts.id = COALESCE((SELECT objects.id FROM objects WHERE objects.multihash = :objectsMultihash AND objects.codec = :objectsCodec LIMIT 1), -1000)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":objectsMultihash", objectsMultihash)
		stmt.SetInt(":objectsCodec", objectsCodec)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: DraftsDelete: %w", err)
	}

	return err
}

func PublicationsUpsert(conn *sqlite.Conn, objectsMultihash []byte, objectsCodec int, publicationsTitle string, publicationsSubtitle string, publicationsCreateTime int, publicationsUpdateTime int, publicationsPublishTime int, publicationsLatestVersion string) error {
	const query = `INSERT OR REPLACE
INTO publications (id, title, subtitle, create_time, update_time, publish_time, latest_version)
VALUES (COALESCE((SELECT objects.id FROM objects WHERE objects.multihash = :objectsMultihash AND objects.codec = :objectsCodec LIMIT 1), -1000), :publicationsTitle, :publicationsSubtitle, :publicationsCreateTime, :publicationsUpdateTime, :publicationsPublishTime, :publicationsLatestVersion)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":objectsMultihash", objectsMultihash)
		stmt.SetInt(":objectsCodec", objectsCodec)
		stmt.SetText(":publicationsTitle", publicationsTitle)
		stmt.SetText(":publicationsSubtitle", publicationsSubtitle)
		stmt.SetInt(":publicationsCreateTime", publicationsCreateTime)
		stmt.SetInt(":publicationsUpdateTime", publicationsUpdateTime)
		stmt.SetInt(":publicationsPublishTime", publicationsPublishTime)
		stmt.SetText(":publicationsLatestVersion", publicationsLatestVersion)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: PublicationsUpsert: %w", err)
	}

	return err
}

type PublicationsListResult struct {
	ObjectsCodec              int
	ObjectsMultihash          []byte
	AccountsCodec             int
	AccountsMultihash         []byte
	PublicationsTitle         string
	PublicationsSubtitle      string
	PublicationsCreateTime    int
	PublicationsUpdateTime    int
	PublicationsPublishTime   int
	PublicationsLatestVersion string
}

func PublicationsList(conn *sqlite.Conn) ([]PublicationsListResult, error) {
	const query = `SELECT objects.codec, objects.multihash, accounts.codec, accounts.multihash, publications.title, publications.subtitle, publications.create_time, publications.update_time, publications.publish_time, publications.latest_version
FROM publications
JOIN objects ON objects.id = publications.id
JOIN accounts ON accounts.id = objects.account_id`

	var out []PublicationsListResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, PublicationsListResult{
			ObjectsCodec:              stmt.ColumnInt(0),
			ObjectsMultihash:          stmt.ColumnBytes(1),
			AccountsCodec:             stmt.ColumnInt(2),
			AccountsMultihash:         stmt.ColumnBytes(3),
			PublicationsTitle:         stmt.ColumnText(4),
			PublicationsSubtitle:      stmt.ColumnText(5),
			PublicationsCreateTime:    stmt.ColumnInt(6),
			PublicationsUpdateTime:    stmt.ColumnInt(7),
			PublicationsPublishTime:   stmt.ColumnInt(8),
			PublicationsLatestVersion: stmt.ColumnText(9),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: PublicationsList: %w", err)
	}

	return out, err
}
