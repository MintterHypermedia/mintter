// Code generated by sqlitegen. DO NOT EDIT.

package sitesql

import (
	"errors"
	"fmt"

	"crawshaw.io/sqlite"
	"mintter/backend/db/sqlitegen"
)

var _ = errors.New

func addSite(conn *sqlite.Conn, accID []byte, sitesAddresses string, sitesHostname string, sitesRole int64) error {
	const query = `INSERT OR REPLACE INTO sites (account_id, addresses, hostname, role)
VALUES ((SELECT id FROM accounts WHERE multihash = :accID), :sitesAddresses, :sitesHostname, :sitesRole)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accID", accID)
		stmt.SetText(":sitesAddresses", sitesAddresses)
		stmt.SetText(":sitesHostname", sitesHostname)
		stmt.SetInt64(":sitesRole", sitesRole)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: addSite: %w", err)
	}

	return err
}

func removeSite(conn *sqlite.Conn, sitesHostname string) error {
	const query = `DELETE FROM sites WHERE sites.hostname = :sitesHostname`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":sitesHostname", sitesHostname)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeSite: %w", err)
	}

	return err
}

type getSiteResult struct {
	SitesAddresses    string
	SitesHostname     string
	SitesRole         int64
	AccountsMultihash []byte
}

func getSite(conn *sqlite.Conn, sitesHostname string) (getSiteResult, error) {
	const query = `SELECT sites.addresses, sites.hostname, sites.role, accounts.multihash
FROM sites
JOIN accounts ON accounts.id = sites.account_id
WHERE sites.hostname = :sitesHostname`

	var out getSiteResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":sitesHostname", sitesHostname)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getSite: more than one result return for a single-kind query")
		}

		out.SitesAddresses = stmt.ColumnText(0)
		out.SitesHostname = stmt.ColumnText(1)
		out.SitesRole = stmt.ColumnInt64(2)
		out.AccountsMultihash = stmt.ColumnBytes(3)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getSite: %w", err)
	}

	return out, err
}

type listSitesResult struct {
	SitesAddresses    string
	SitesHostname     string
	SitesRole         int64
	AccountsMultihash []byte
}

func listSites(conn *sqlite.Conn) ([]listSitesResult, error) {
	const query = `SELECT sites.addresses, sites.hostname, sites.role, accounts.multihash
FROM sites
JOIN accounts ON accounts.id = sites.account_id`

	var out []listSitesResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listSitesResult{
			SitesAddresses:    stmt.ColumnText(0),
			SitesHostname:     stmt.ColumnText(1),
			SitesRole:         stmt.ColumnInt64(2),
			AccountsMultihash: stmt.ColumnBytes(3),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listSites: %w", err)
	}

	return out, err
}

func setSiteTitle(conn *sqlite.Conn, title string) error {
	const query = `INSERT OR REPLACE INTO global_meta (key, value)
VALUES ('site_title', :title)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":title", title)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: setSiteTitle: %w", err)
	}

	return err
}

type getSiteTitleResult struct {
	GlobalMetaValue string
}

func getSiteTitle(conn *sqlite.Conn) (getSiteTitleResult, error) {
	const query = `SELECT global_meta.value FROM global_meta WHERE global_meta.key ='site_title'`

	var out getSiteTitleResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getSiteTitle: more than one result return for a single-kind query")
		}

		out.GlobalMetaValue = stmt.ColumnText(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getSiteTitle: %w", err)
	}

	return out, err
}

func setSiteDescription(conn *sqlite.Conn, description string) error {
	const query = `INSERT OR REPLACE INTO global_meta (key, value)
VALUES ('site_description', :description)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":description", description)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: setSiteDescription: %w", err)
	}

	return err
}

type getSiteDescriptionResult struct {
	GlobalMetaValue string
}

func getSiteDescription(conn *sqlite.Conn) (getSiteDescriptionResult, error) {
	const query = `SELECT global_meta.value FROM global_meta WHERE global_meta.key ='site_description'`

	var out getSiteDescriptionResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getSiteDescription: more than one result return for a single-kind query")
		}

		out.GlobalMetaValue = stmt.ColumnText(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getSiteDescription: %w", err)
	}

	return out, err
}

func addToken(conn *sqlite.Conn, inviteTokensToken string, inviteTokensExpirationTime int64, inviteTokensRole int64) error {
	const query = `INSERT INTO invite_tokens (token, expiration_time, role)
VALUES (:inviteTokensToken, :inviteTokensExpirationTime, :inviteTokensRole)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":inviteTokensToken", inviteTokensToken)
		stmt.SetInt64(":inviteTokensExpirationTime", inviteTokensExpirationTime)
		stmt.SetInt64(":inviteTokensRole", inviteTokensRole)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: addToken: %w", err)
	}

	return err
}

type getTokenResult struct {
	InviteTokensRole           int64
	InviteTokensExpirationTime int64
}

func getToken(conn *sqlite.Conn, inviteTokensToken string) (getTokenResult, error) {
	const query = `SELECT invite_tokens.role, invite_tokens.expiration_time
FROM invite_tokens WHERE invite_tokens.token = :inviteTokensToken`

	var out getTokenResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":inviteTokensToken", inviteTokensToken)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getToken: more than one result return for a single-kind query")
		}

		out.InviteTokensRole = stmt.ColumnInt64(0)
		out.InviteTokensExpirationTime = stmt.ColumnInt64(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getToken: %w", err)
	}

	return out, err
}

type listTokensResult struct {
	InviteTokensRole           int64
	InviteTokensExpirationTime int64
	InviteTokensToken          string
}

func listTokens(conn *sqlite.Conn) ([]listTokensResult, error) {
	const query = `SELECT invite_tokens.role, invite_tokens.expiration_time, invite_tokens.token
FROM invite_tokens`

	var out []listTokensResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listTokensResult{
			InviteTokensRole:           stmt.ColumnInt64(0),
			InviteTokensExpirationTime: stmt.ColumnInt64(1),
			InviteTokensToken:          stmt.ColumnText(2),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listTokens: %w", err)
	}

	return out, err
}

func removeToken(conn *sqlite.Conn, inviteTokensToken string) error {
	const query = `DELETE FROM invite_tokens WHERE invite_tokens.token = :inviteTokensToken`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":inviteTokensToken", inviteTokensToken)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeToken: %w", err)
	}

	return err
}

func removeExpiredTokens(conn *sqlite.Conn) error {
	const query = `DELETE FROM invite_tokens WHERE invite_tokens.expiration_time < strftime('%s', 'now')`

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeExpiredTokens: %w", err)
	}

	return err
}

type addMemberResult struct {
	SiteMembersRole int64
}

func addMember(conn *sqlite.Conn, accID []byte, siteMembersRole int64) (addMemberResult, error) {
	const query = `INSERT OR REPLACE INTO site_members (account_id, role)
VALUES ((SELECT id FROM accounts WHERE multihash = :accID), :siteMembersRole)
RETURNING site_members.role`

	var out addMemberResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accID", accID)
		stmt.SetInt64(":siteMembersRole", siteMembersRole)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("addMember: more than one result return for a single-kind query")
		}

		out.SiteMembersRole = stmt.ColumnInt64(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: addMember: %w", err)
	}

	return out, err
}

func removeMember(conn *sqlite.Conn, accID []byte) error {
	const query = `DELETE FROM site_members WHERE site_members.account_id =(SELECT id FROM accounts WHERE multihash = :accID )`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accID", accID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeMember: %w", err)
	}

	return err
}

type getMemberResult struct {
	SiteMembersRole int64
}

func getMember(conn *sqlite.Conn, accID []byte) (getMemberResult, error) {
	const query = `SELECT site_members.role
FROM site_members WHERE site_members.account_id =(SELECT id FROM accounts WHERE multihash = :accID )`

	var out getMemberResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accID", accID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getMember: more than one result return for a single-kind query")
		}

		out.SiteMembersRole = stmt.ColumnInt64(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getMember: %w", err)
	}

	return out, err
}

type listMembersResult struct {
	SiteMembersRole   int64
	AccountsMultihash []byte
}

func listMembers(conn *sqlite.Conn) ([]listMembersResult, error) {
	const query = `SELECT site_members.role, accounts.multihash
FROM site_members
JOIN accounts ON accounts.id = site_members.account_id`

	var out []listMembersResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listMembersResult{
			SiteMembersRole:   stmt.ColumnInt64(0),
			AccountsMultihash: stmt.ColumnBytes(1),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listMembers: %w", err)
	}

	return out, err
}

func addWebPublicationRecord(conn *sqlite.Conn, webPublicationRecordsDocumentID int64, webPublicationRecordsDocumentVersion string, webPublicationRecordsPath string) error {
	const query = `INSERT INTO web_publication_records (document_id, document_version, path)
VALUES (:webPublicationRecordsDocumentID, :webPublicationRecordsDocumentVersion, :webPublicationRecordsPath)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt64(":webPublicationRecordsDocumentID", webPublicationRecordsDocumentID)
		stmt.SetText(":webPublicationRecordsDocumentVersion", webPublicationRecordsDocumentVersion)
		stmt.SetText(":webPublicationRecordsPath", webPublicationRecordsPath)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: addWebPublicationRecord: %w", err)
	}

	return err
}

func removeWebPublicationRecord(conn *sqlite.Conn, webPublicationRecordsID int64) error {
	const query = `DELETE FROM web_publication_records WHERE web_publication_records.id = :webPublicationRecordsID`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt64(":webPublicationRecordsID", webPublicationRecordsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeWebPublicationRecord: %w", err)
	}

	return err
}

type listWebPublicationRecordsResult struct {
	WebPublicationRecordsID              int64
	WebPublicationRecordsDocumentID      int64
	WebPublicationRecordsDocumentVersion string
	WebPublicationRecordsPath            string
}

func listWebPublicationRecords(conn *sqlite.Conn) ([]listWebPublicationRecordsResult, error) {
	const query = `SELECT web_publication_records.id, web_publication_records.document_id, web_publication_records.document_version, web_publication_records.path
FROM web_publication_records`

	var out []listWebPublicationRecordsResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listWebPublicationRecordsResult{
			WebPublicationRecordsID:              stmt.ColumnInt64(0),
			WebPublicationRecordsDocumentID:      stmt.ColumnInt64(1),
			WebPublicationRecordsDocumentVersion: stmt.ColumnText(2),
			WebPublicationRecordsPath:            stmt.ColumnText(3),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listWebPublicationRecords: %w", err)
	}

	return out, err
}

type getWebPublicationRecordResult struct {
	WebPublicationRecordsDocumentID      int64
	WebPublicationRecordsDocumentVersion string
	WebPublicationRecordsPath            string
}

func getWebPublicationRecord(conn *sqlite.Conn, webPublicationRecordsID int64) (getWebPublicationRecordResult, error) {
	const query = `SELECT web_publication_records.document_id, web_publication_records.document_version, web_publication_records.path
FROM web_publication_records WHERE web_publication_records.id = :webPublicationRecordsID`

	var out getWebPublicationRecordResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt64(":webPublicationRecordsID", webPublicationRecordsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getWebPublicationRecord: more than one result return for a single-kind query")
		}

		out.WebPublicationRecordsDocumentID = stmt.ColumnInt64(0)
		out.WebPublicationRecordsDocumentVersion = stmt.ColumnText(1)
		out.WebPublicationRecordsPath = stmt.ColumnText(2)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getWebPublicationRecord: %w", err)
	}

	return out, err
}

type getWebPublicationReferencesResult struct {
	ContentLinksTargetDocumentID int64
	ContentLinksTargetVersion    string
}

func getWebPublicationReferences(conn *sqlite.Conn, webPublicationRecordsDocumentID int64) ([]getWebPublicationReferencesResult, error) {
	const query = `SELECT content_links.target_document_id, content_links.target_version
FROM web_publication_records WHERE content_links.source_document_id = :webPublicationRecordsDocumentID`

	var out []getWebPublicationReferencesResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt64(":webPublicationRecordsDocumentID", webPublicationRecordsDocumentID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, getWebPublicationReferencesResult{
			ContentLinksTargetDocumentID: stmt.ColumnInt64(0),
			ContentLinksTargetVersion:    stmt.ColumnText(1),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getWebPublicationReferences: %w", err)
	}

	return out, err
}

type getWebPublicationReferencesWithVersionResult struct {
	ContentLinksTargetDocumentID int64
	ContentLinksTargetVersion    string
}

func getWebPublicationReferencesWithVersion(conn *sqlite.Conn, webPublicationRecordsDocumentID int64, webPublicationRecordsDocumentVersion string) ([]getWebPublicationReferencesWithVersionResult, error) {
	const query = `SELECT content_links.target_document_id, content_links.target_version
FROM web_publication_records WHERE content_links.source_document_id = :webPublicationRecordsDocumentID AND content_links.source_version = :webPublicationRecordsDocumentVersion`

	var out []getWebPublicationReferencesWithVersionResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt64(":webPublicationRecordsDocumentID", webPublicationRecordsDocumentID)
		stmt.SetText(":webPublicationRecordsDocumentVersion", webPublicationRecordsDocumentVersion)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, getWebPublicationReferencesWithVersionResult{
			ContentLinksTargetDocumentID: stmt.ColumnInt64(0),
			ContentLinksTargetVersion:    stmt.ColumnText(1),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getWebPublicationReferencesWithVersion: %w", err)
	}

	return out, err
}

type countWebPublicationExistingReferencesResult struct {
	Count                        int64
	ContentLinksSourceDocumentID int64
}

func countWebPublicationExistingReferences(conn *sqlite.Conn, webPublicationRecordsDocumentID int64) (countWebPublicationExistingReferencesResult, error) {
	const query = `SELECT COUNT(DISTINCT target_version) AS count, content_links.source_document_id
FROM content_links WHERE content_links.source_document_id = :webPublicationRecordsDocumentID`

	var out countWebPublicationExistingReferencesResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt64(":webPublicationRecordsDocumentID", webPublicationRecordsDocumentID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("countWebPublicationExistingReferences: more than one result return for a single-kind query")
		}

		out.Count = stmt.ColumnInt64(0)
		out.ContentLinksSourceDocumentID = stmt.ColumnInt64(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: countWebPublicationExistingReferences: %w", err)
	}

	return out, err
}

type countWebPublicationExistingReferencesWithVersionResult struct {
	Count                        int64
	ContentLinksSourceDocumentID int64
}

func countWebPublicationExistingReferencesWithVersion(conn *sqlite.Conn, webPublicationRecordsDocumentID int64, webPublicationRecordsDocumentVersion string) (countWebPublicationExistingReferencesWithVersionResult, error) {
	const query = `SELECT COUNT(DISTINCT target_version) AS count, content_links.source_document_id
FROM content_links WHERE content_links.source_document_id = :webPublicationRecordsDocumentID AND content_links.source_version = :webPublicationRecordsDocumentVersion`

	var out countWebPublicationExistingReferencesWithVersionResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt64(":webPublicationRecordsDocumentID", webPublicationRecordsDocumentID)
		stmt.SetText(":webPublicationRecordsDocumentVersion", webPublicationRecordsDocumentVersion)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("countWebPublicationExistingReferencesWithVersion: more than one result return for a single-kind query")
		}

		out.Count = stmt.ColumnInt64(0)
		out.ContentLinksSourceDocumentID = stmt.ColumnInt64(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: countWebPublicationExistingReferencesWithVersion: %w", err)
	}

	return out, err
}
