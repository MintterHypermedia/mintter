// Code generated by sqlitegen. DO NOT EDIT.

package sitesql

import (
	"errors"
	"fmt"

	"crawshaw.io/sqlite"
	"mintter/backend/db/sqlitegen"
)

var _ = errors.New

func addSite(conn *sqlite.Conn, accID []byte, sitesAddresses string, sitesHostname string, sitesRole int64) error {
	const query = `INSERT OR REPLACE INTO sites (account_id, addresses, hostname, role)
VALUES ((SELECT id FROM accounts WHERE multihash = :accID), :sitesAddresses, :sitesHostname, :sitesRole)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accID", accID)
		stmt.SetText(":sitesAddresses", sitesAddresses)
		stmt.SetText(":sitesHostname", sitesHostname)
		stmt.SetInt64(":sitesRole", sitesRole)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: addSite: %w", err)
	}

	return err
}

func removeSite(conn *sqlite.Conn, sitesHostname string) error {
	const query = `DELETE FROM sites WHERE sites.hostname = :sitesHostname`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":sitesHostname", sitesHostname)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeSite: %w", err)
	}

	return err
}

type getSiteResult struct {
	SitesAddresses    string
	SitesHostname     string
	SitesRole         int64
	AccountsMultihash []byte
}

func getSite(conn *sqlite.Conn, sitesHostname string) (getSiteResult, error) {
	const query = `SELECT sites.addresses, sites.hostname, sites.role, accounts.multihash
FROM sites
JOIN accounts ON accounts.id = sites.account_id
WHERE sites.hostname = :sitesHostname`

	var out getSiteResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":sitesHostname", sitesHostname)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getSite: more than one result return for a single-kind query")
		}

		out.SitesAddresses = stmt.ColumnText(0)
		out.SitesHostname = stmt.ColumnText(1)
		out.SitesRole = stmt.ColumnInt64(2)
		out.AccountsMultihash = stmt.ColumnBytes(3)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getSite: %w", err)
	}

	return out, err
}

type listSitesResult struct {
	SitesAddresses    string
	SitesHostname     string
	SitesRole         int64
	AccountsMultihash []byte
}

func listSites(conn *sqlite.Conn) ([]listSitesResult, error) {
	const query = `SELECT sites.addresses, sites.hostname, sites.role, accounts.multihash
FROM sites
JOIN accounts ON accounts.id = sites.account_id`

	var out []listSitesResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listSitesResult{
			SitesAddresses:    stmt.ColumnText(0),
			SitesHostname:     stmt.ColumnText(1),
			SitesRole:         stmt.ColumnInt64(2),
			AccountsMultihash: stmt.ColumnBytes(3),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listSites: %w", err)
	}

	return out, err
}

func setSiteTitle(conn *sqlite.Conn, title string) error {
	const query = `INSERT OR REPLACE INTO global_meta (key, value)
VALUES ('site_title', :title)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":title", title)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: setSiteTitle: %w", err)
	}

	return err
}

type getSiteTitleResult struct {
	GlobalMetaValue string
}

func getSiteTitle(conn *sqlite.Conn) (getSiteTitleResult, error) {
	const query = `SELECT global_meta.value FROM global_meta WHERE global_meta.key ='site_title'`

	var out getSiteTitleResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getSiteTitle: more than one result return for a single-kind query")
		}

		out.GlobalMetaValue = stmt.ColumnText(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getSiteTitle: %w", err)
	}

	return out, err
}

func setSiteDescription(conn *sqlite.Conn, description string) error {
	const query = `INSERT OR REPLACE INTO global_meta (key, value)
VALUES ('site_description', :description)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":description", description)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: setSiteDescription: %w", err)
	}

	return err
}

type getSiteDescriptionResult struct {
	GlobalMetaValue string
}

func getSiteDescription(conn *sqlite.Conn) (getSiteDescriptionResult, error) {
	const query = `SELECT global_meta.value FROM global_meta WHERE global_meta.key ='site_description'`

	var out getSiteDescriptionResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getSiteDescription: more than one result return for a single-kind query")
		}

		out.GlobalMetaValue = stmt.ColumnText(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getSiteDescription: %w", err)
	}

	return out, err
}

func addToken(conn *sqlite.Conn, inviteTokensToken string, inviteTokensExpirationTime int64, inviteTokensRole int64) error {
	const query = `INSERT INTO invite_tokens (token, expiration_time, role)
VALUES (:inviteTokensToken, :inviteTokensExpirationTime, :inviteTokensRole)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":inviteTokensToken", inviteTokensToken)
		stmt.SetInt64(":inviteTokensExpirationTime", inviteTokensExpirationTime)
		stmt.SetInt64(":inviteTokensRole", inviteTokensRole)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: addToken: %w", err)
	}

	return err
}

type getTokenResult struct {
	InviteTokensRole           int64
	InviteTokensExpirationTime int64
}

func getToken(conn *sqlite.Conn, inviteTokensToken string) (getTokenResult, error) {
	const query = `SELECT invite_tokens.role, invite_tokens.expiration_time
FROM invite_tokens WHERE invite_tokens.token = :inviteTokensToken`

	var out getTokenResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":inviteTokensToken", inviteTokensToken)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getToken: more than one result return for a single-kind query")
		}

		out.InviteTokensRole = stmt.ColumnInt64(0)
		out.InviteTokensExpirationTime = stmt.ColumnInt64(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getToken: %w", err)
	}

	return out, err
}

type listTokensResult struct {
	InviteTokensRole           int64
	InviteTokensExpirationTime int64
	InviteTokensToken          string
}

func listTokens(conn *sqlite.Conn) ([]listTokensResult, error) {
	const query = `SELECT invite_tokens.role, invite_tokens.expiration_time, invite_tokens.token
FROM invite_tokens`

	var out []listTokensResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listTokensResult{
			InviteTokensRole:           stmt.ColumnInt64(0),
			InviteTokensExpirationTime: stmt.ColumnInt64(1),
			InviteTokensToken:          stmt.ColumnText(2),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listTokens: %w", err)
	}

	return out, err
}

func removeToken(conn *sqlite.Conn, inviteTokensToken string) error {
	const query = `DELETE FROM invite_tokens WHERE invite_tokens.token = :inviteTokensToken`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":inviteTokensToken", inviteTokensToken)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeToken: %w", err)
	}

	return err
}

func removeExpiredTokens(conn *sqlite.Conn) error {
	const query = `DELETE FROM invite_tokens WHERE invite_tokens.expiration_time < strftime('%s', 'now')`

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeExpiredTokens: %w", err)
	}

	return err
}

type addMemberResult struct {
	SiteMembersRole int64
}

func addMember(conn *sqlite.Conn, accID []byte, siteMembersRole int64) (addMemberResult, error) {
	const query = `INSERT OR REPLACE INTO site_members (account_id, role)
VALUES ((SELECT id FROM accounts WHERE multihash = :accID), :siteMembersRole)
RETURNING site_members.role`

	var out addMemberResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accID", accID)
		stmt.SetInt64(":siteMembersRole", siteMembersRole)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("addMember: more than one result return for a single-kind query")
		}

		out.SiteMembersRole = stmt.ColumnInt64(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: addMember: %w", err)
	}

	return out, err
}

func removeMember(conn *sqlite.Conn, accID []byte) error {
	const query = `DELETE FROM site_members WHERE site_members.account_id =(SELECT id FROM accounts WHERE multihash = :accID )`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accID", accID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeMember: %w", err)
	}

	return err
}

type getMemberResult struct {
	SiteMembersRole int64
}

func getMember(conn *sqlite.Conn, accID []byte) (getMemberResult, error) {
	const query = `SELECT site_members.role
FROM site_members WHERE site_members.account_id =(SELECT id FROM accounts WHERE multihash = :accID )`

	var out getMemberResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":accID", accID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getMember: more than one result return for a single-kind query")
		}

		out.SiteMembersRole = stmt.ColumnInt64(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getMember: %w", err)
	}

	return out, err
}

type listMembersResult struct {
	SiteMembersRole   int64
	AccountsMultihash []byte
}

func listMembers(conn *sqlite.Conn) ([]listMembersResult, error) {
	const query = `SELECT site_members.role, accounts.multihash
FROM site_members
JOIN accounts ON accounts.id = site_members.account_id`

	var out []listMembersResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listMembersResult{
			SiteMembersRole:   stmt.ColumnInt64(0),
			AccountsMultihash: stmt.ColumnBytes(1),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listMembers: %w", err)
	}

	return out, err
}

func addWebPublicationRecord(conn *sqlite.Conn, doc_multihash []byte, webPublicationRecordsDocumentVersion string, webPublicationRecordsPath string) error {
	const query = `INSERT INTO web_publication_records (block_id, document_version, path)
VALUES ((SELECT id FROM ipfs_blocks WHERE multihash = :doc_multihash), :webPublicationRecordsDocumentVersion, :webPublicationRecordsPath)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":doc_multihash", doc_multihash)
		stmt.SetText(":webPublicationRecordsDocumentVersion", webPublicationRecordsDocumentVersion)
		stmt.SetText(":webPublicationRecordsPath", webPublicationRecordsPath)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: addWebPublicationRecord: %w", err)
	}

	return err
}

func removeWebPublicationRecord(conn *sqlite.Conn, doc_multihash []byte, webPublicationRecordsDocumentVersion string) error {
	const query = `DELETE FROM web_publication_records WHERE web_publication_records.block_id =(SELECT id FROM ipfs_blocks WHERE multihash = :doc_multihash ) AND web_publication_records.document_version = :webPublicationRecordsDocumentVersion`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":doc_multihash", doc_multihash)
		stmt.SetText(":webPublicationRecordsDocumentVersion", webPublicationRecordsDocumentVersion)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: removeWebPublicationRecord: %w", err)
	}

	return err
}

type listWebPublicationRecordsResult struct {
	IPFSBlocksCodec                      int64
	IPFSBlocksMultihash                  []byte
	WebPublicationRecordsDocumentVersion string
	WebPublicationRecordsPath            string
}

func listWebPublicationRecords(conn *sqlite.Conn) ([]listWebPublicationRecordsResult, error) {
	const query = `SELECT ipfs_blocks.codec, ipfs_blocks.multihash, web_publication_records.document_version, web_publication_records.path
FROM web_publication_records
JOIN ipfs_blocks ON web_publication_records.block_id = ipfs_blocks.id`

	var out []listWebPublicationRecordsResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listWebPublicationRecordsResult{
			IPFSBlocksCodec:                      stmt.ColumnInt64(0),
			IPFSBlocksMultihash:                  stmt.ColumnBytes(1),
			WebPublicationRecordsDocumentVersion: stmt.ColumnText(2),
			WebPublicationRecordsPath:            stmt.ColumnText(3),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listWebPublicationRecords: %w", err)
	}

	return out, err
}

type getWebPublicationRecordByIDOnlyResult struct {
	IPFSBlocksCodec                      int64
	IPFSBlocksMultihash                  []byte
	WebPublicationRecordsDocumentVersion string
	WebPublicationRecordsPath            string
}

func getWebPublicationRecordByIDOnly(conn *sqlite.Conn, doc_multihash []byte) ([]getWebPublicationRecordByIDOnlyResult, error) {
	const query = `SELECT ipfs_blocks.codec, ipfs_blocks.multihash, web_publication_records.document_version, web_publication_records.path
FROM web_publication_records
JOIN ipfs_blocks ON web_publication_records.block_id = ipfs_blocks.id WHERE web_publication_records.block_id =(SELECT id FROM ipfs_blocks WHERE multihash = :doc_multihash )`

	var out []getWebPublicationRecordByIDOnlyResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":doc_multihash", doc_multihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, getWebPublicationRecordByIDOnlyResult{
			IPFSBlocksCodec:                      stmt.ColumnInt64(0),
			IPFSBlocksMultihash:                  stmt.ColumnBytes(1),
			WebPublicationRecordsDocumentVersion: stmt.ColumnText(2),
			WebPublicationRecordsPath:            stmt.ColumnText(3),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getWebPublicationRecordByIDOnly: %w", err)
	}

	return out, err
}

type getWebPublicationRecordWithVersionResult struct {
	IPFSBlocksCodec                      int64
	IPFSBlocksMultihash                  []byte
	WebPublicationRecordsDocumentVersion string
	WebPublicationRecordsPath            string
}

func getWebPublicationRecordWithVersion(conn *sqlite.Conn, doc_multihash []byte, doc_version string) (getWebPublicationRecordWithVersionResult, error) {
	const query = `SELECT ipfs_blocks.codec, ipfs_blocks.multihash, web_publication_records.document_version, web_publication_records.path
FROM web_publication_records
JOIN ipfs_blocks ON web_publication_records.block_id = ipfs_blocks.id WHERE web_publication_records.block_id =(SELECT id FROM ipfs_blocks WHERE multihash = :doc_multihash ) AND web_publication_records.document_version = :doc_version`

	var out getWebPublicationRecordWithVersionResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":doc_multihash", doc_multihash)
		stmt.SetText(":doc_version", doc_version)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getWebPublicationRecordWithVersion: more than one result return for a single-kind query")
		}

		out.IPFSBlocksCodec = stmt.ColumnInt64(0)
		out.IPFSBlocksMultihash = stmt.ColumnBytes(1)
		out.WebPublicationRecordsDocumentVersion = stmt.ColumnText(2)
		out.WebPublicationRecordsPath = stmt.ColumnText(3)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getWebPublicationRecordWithVersion: %w", err)
	}

	return out, err
}

type getWebPublicationRecordByPathResult struct {
	IPFSBlocksCodec                      int64
	IPFSBlocksMultihash                  []byte
	WebPublicationRecordsDocumentVersion string
	WebPublicationRecordsPath            string
}

func getWebPublicationRecordByPath(conn *sqlite.Conn, webPublicationRecordsPath string) (getWebPublicationRecordByPathResult, error) {
	const query = `SELECT ipfs_blocks.codec, ipfs_blocks.multihash, web_publication_records.document_version, web_publication_records.path
FROM web_publication_records
JOIN ipfs_blocks ON web_publication_records.block_id = ipfs_blocks.id WHERE web_publication_records.path = :webPublicationRecordsPath`

	var out getWebPublicationRecordByPathResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":webPublicationRecordsPath", webPublicationRecordsPath)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getWebPublicationRecordByPath: more than one result return for a single-kind query")
		}

		out.IPFSBlocksCodec = stmt.ColumnInt64(0)
		out.IPFSBlocksMultihash = stmt.ColumnBytes(1)
		out.WebPublicationRecordsDocumentVersion = stmt.ColumnText(2)
		out.WebPublicationRecordsPath = stmt.ColumnText(3)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getWebPublicationRecordByPath: %w", err)
	}

	return out, err
}

type listWebPublicationReferencesByIDOnlyResult struct {
	IPFSBlocksCodec           int64
	IPFSBlocksMultihash       []byte
	ContentLinksTargetVersion string
}

func listWebPublicationReferencesByIDOnly(conn *sqlite.Conn, doc_multihash []byte) ([]listWebPublicationReferencesByIDOnlyResult, error) {
	const query = `SELECT ipfs_blocks.codec, ipfs_blocks.multihash, content_links.target_version
FROM content_links
JOIN ipfs_blocks ON content_links.target_document_id = ipfs_blocks.id WHERE content_links.source_document_id =(SELECT id FROM ipfs_blocks WHERE multihash = :doc_multihash )`

	var out []listWebPublicationReferencesByIDOnlyResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":doc_multihash", doc_multihash)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listWebPublicationReferencesByIDOnlyResult{
			IPFSBlocksCodec:           stmt.ColumnInt64(0),
			IPFSBlocksMultihash:       stmt.ColumnBytes(1),
			ContentLinksTargetVersion: stmt.ColumnText(2),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listWebPublicationReferencesByIDOnly: %w", err)
	}

	return out, err
}

type listWebPublicationReferencesWithVersionResult struct {
	IPFSBlocksCodec           int64
	IPFSBlocksMultihash       []byte
	ContentLinksTargetVersion string
}

func listWebPublicationReferencesWithVersion(conn *sqlite.Conn, doc_multihash []byte, doc_version string) ([]listWebPublicationReferencesWithVersionResult, error) {
	const query = `SELECT ipfs_blocks.codec, ipfs_blocks.multihash, content_links.target_version
FROM content_links
JOIN ipfs_blocks ON content_links.target_document_id = ipfs_blocks.id WHERE content_links.source_document_id =(SELECT id FROM ipfs_blocks WHERE multihash = :doc_multihash ) AND content_links.source_version = :doc_version`

	var out []listWebPublicationReferencesWithVersionResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":doc_multihash", doc_multihash)
		stmt.SetText(":doc_version", doc_version)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listWebPublicationReferencesWithVersionResult{
			IPFSBlocksCodec:           stmt.ColumnInt64(0),
			IPFSBlocksMultihash:       stmt.ColumnBytes(1),
			ContentLinksTargetVersion: stmt.ColumnText(2),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listWebPublicationReferencesWithVersion: %w", err)
	}

	return out, err
}
