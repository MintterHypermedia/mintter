// Code generated by sqlitegen. DO NOT EDIT.

package wallet

import (
	"errors"

	"crawshaw.io/sqlite"
	"go.uber.org/multierr"
)

var _ = errors.New

func execStmt(conn *sqlite.Conn, query string, before func(*sqlite.Stmt), onStep func(int, *sqlite.Stmt) error) (err error) {
	stmt, err := conn.Prepare(query)
	if err != nil {
		return err
	}
	defer func() {
		err = multierr.Append(err, stmt.Reset())
	}()

	before(stmt)

	for i := 0; true; i++ {
		hasRow, err := stmt.Step()
		if err != nil {
			return err
		}

		if !hasRow {
			break
		}

		if err := onStep(i, stmt); err != nil {
			return err
		}
	}

	return err
}

func insertWallet(conn *sqlite.Conn, walletsID string, walletsAddress string, walletsType string, walletsAuth []byte, walletsName string, walletsBalance int) error {
	const query = `INSERT INTO wallets (id, address, type, auth, name, balance)
VALUES (?, ?, ?, ?, ?, ?)`

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, walletsID)
		stmt.BindText(2, walletsAddress)
		stmt.BindText(3, walletsType)
		stmt.BindBytes(4, walletsAuth)
		stmt.BindText(5, walletsName)
		stmt.BindInt(6, walletsBalance)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return err
	}

	return nil
}

type getWalletResult struct {
	WalletsID      string
	WalletsAddress string
	WalletsName    string
	WalletsBalance int
	WalletsType    string
}

func getWallet(conn *sqlite.Conn, walletsID string) (getWalletResult, error) {
	const query = `SELECT wallets.id, wallets.address, wallets.name, wallets.balance, wallets.type
FROM wallets WHERE wallets.id = ?`

	var out getWalletResult

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getWallet: more than one result return for a single-kind query")
		}

		out.WalletsID = stmt.ColumnText(0)
		out.WalletsAddress = stmt.ColumnText(1)
		out.WalletsName = stmt.ColumnText(2)
		out.WalletsBalance = stmt.ColumnInt(3)
		out.WalletsType = stmt.ColumnText(4)
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return out, err
	}

	return out, nil
}

type listWalletsResult struct {
	WalletsID      string
	WalletsAddress string
	WalletsName    string
	WalletsType    string
	WalletsBalance int
}

func listWallets(conn *sqlite.Conn, cursor string, limit int) ([]listWalletsResult, error) {
	const query = `SELECT wallets.id, wallets.address, wallets.name, wallets.type, wallets.balance FROM wallets WHERE wallets.id > ? LIMIT ?`

	var out []listWalletsResult

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, cursor)
		stmt.BindInt(2, limit)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listWalletsResult{})
		out[i].WalletsID = stmt.ColumnText(0)
		out[i].WalletsAddress = stmt.ColumnText(1)
		out[i].WalletsName = stmt.ColumnText(2)
		out[i].WalletsType = stmt.ColumnText(3)
		out[i].WalletsBalance = stmt.ColumnInt(4)
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return nil, err
	}

	return out, nil
}

type getDefaultWalletResult struct {
	WalletsID       string
	WalletsAddress  string
	WalletsName     string
	WalletsBalance  int
	WalletsType     string
	GlobalMetaValue string
}

func getDefaultWallet(conn *sqlite.Conn, key string) (getDefaultWalletResult, error) {
	const query = `SELECT wallets.id, wallets.address, wallets.name, wallets.balance, wallets.type
FROM wallets
WHERE wallets.id IN (SELECT global_meta.value
FROM global_meta
WHERE global_meta.key = ? )`

	var out getDefaultWalletResult

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, key)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getDefaultWallet: more than one result return for a single-kind query")
		}

		out.WalletsID = stmt.ColumnText(0)
		out.WalletsAddress = stmt.ColumnText(1)
		out.WalletsName = stmt.ColumnText(2)
		out.WalletsBalance = stmt.ColumnInt(3)
		out.WalletsType = stmt.ColumnText(4)
		out.GlobalMetaValue = stmt.ColumnText(5)
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return out, err
	}

	return out, nil
}

func setDefaultWallet(conn *sqlite.Conn, globalMetaKey string, globalMetaValue string) error {
	const query = `INSERT OR REPLACE INTO global_meta (key, value)
VALUES (?, ?)`

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, globalMetaKey)
		stmt.BindText(2, globalMetaValue)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return err
	}

	return nil
}

func removeDefaultWallet(conn *sqlite.Conn, key string) error {
	const query = `DELETE FROM global_meta WHERE global_meta.key = ? `

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, key)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return err
	}

	return nil
}

func updateWalletName(conn *sqlite.Conn, walletsName string, walletsID string) error {
	const query = `UPDATE wallets SET (name)
=( ? ) WHERE wallets.id = ?`

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, walletsName)
		stmt.BindText(2, walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return err
	}

	return nil
}

func removeWallet(conn *sqlite.Conn, walletsID string) error {
	const query = `DELETE FROM wallets WHERE wallets.id = ?`

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return err
	}

	return nil
}

type getWalletCountResult struct {
	Count int
}

func getWalletCount(conn *sqlite.Conn) (getWalletCountResult, error) {
	const query = `SELECT COUNT(wallets.id) AS count FROM wallets`

	var out getWalletCountResult

	before := func(stmt *sqlite.Stmt) {
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getWalletCount: more than one result return for a single-kind query")
		}

		out.Count = stmt.ColumnInt(0)
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return out, err
	}

	return out, nil
}

type getWalletAuthResult struct {
	WalletsAuth []byte
}

func getWalletAuth(conn *sqlite.Conn, walletsID string) (getWalletAuthResult, error) {
	const query = `SELECT wallets.auth FROM wallets WHERE wallets.id = ?`

	var out getWalletAuthResult

	before := func(stmt *sqlite.Stmt) {
		stmt.BindText(1, walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getWalletAuth: more than one result return for a single-kind query")
		}

		out.WalletsAuth = stmt.ColumnBytes(0)
		return nil
	}

	if err := execStmt(conn, query, before, onStep); err != nil {
		return out, err
	}

	return out, nil
}
