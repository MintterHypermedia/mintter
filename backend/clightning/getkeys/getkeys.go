package getkeys

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/btcsuite/btcd/btcutil"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/niftynei/glightning/glightning"
	"github.com/niftynei/glightning/jrpc2"
)

const (
	HSM_SECRET                    = "hsm_secret"
	DB_NAME                       = "lightningd.sqlite3"
	KEY_SALT                      = "bip32 seed"
	UNENCRYPTED_HSM_SECRET_LENGTH = 32
)

var plugin *glightning.Plugin
var lightning *glightning.Lightning
var lightningdir string
var bitcoinNet *chaincfg.Params

type GetKeys struct {
	DerivationPath  string `json:"derivationpath,omitempty"`
	HsmSecretPath   string `json:"hsmsecretpath,omitempty"`
	DbPath          string `json:"dbpath,omitempty"`
	HsmPasswordFile string `json:"hsmpasswordfile,omitempty"`
	NewAddr         bool   `json:"newaddr,omitempty"`
}

type GetKeysResult struct {
	Xpriv   string `json:"xpriv"`
	Wif     string `json:"wif"`
	Xpub    string `json:"xpub"`
	Bech32  string `json:"bech32"`
	DerPath string `json:"derpath,omitempty"`
}

func (g *GetKeys) Call() (jrpc2.Result, error) {

	if g.DerivationPath == "" && !g.NewAddr {
		return nil, fmt.Errorf("neither derivationpath nor newaddr were provided. You should provide one of them")
	}

	if g.DerivationPath != "" && g.NewAddr {
		return nil, fmt.Errorf("you must provide either derivationpath or newaddr, not both")
	}

	if g.HsmSecretPath == "" {
		g.HsmSecretPath = lightningdir + "/" + HSM_SECRET
	}

	if g.DbPath == "" {
		g.DbPath = lightningdir + "/" + DB_NAME
	}

	hsm_secret, err := decrypt_hsm(g.HsmPasswordFile, g.HsmSecretPath)
	if err != nil {
		return nil, err
	}

	var dev_path []string
	var lastAddr string = ""
	if g.NewAddr {
		lastAddr, err = lightning.NewAddr()
		if err != nil {
			return nil, err
		}
		db, err := openDB(g.DbPath)
		if err != nil {
			return nil, err
		}
		defer db.Close()
		idx, err := getCurrentIdx(db)
		if err != nil {
			return nil, err
		}
		dev_path = []string{"m", "0", "0", strconv.FormatInt(int64(idx), 10)}
	} else {
		dev_path = strings.FieldsFunc(g.DerivationPath, func(c rune) bool { return c == '/' })
	}

	key, err := derive(hsm_secret, dev_path)
	if err != nil {
		return nil, err
	}

	pub, err := key.Neuter()
	if err != nil {
		return nil, err
	}

	pubkey, err := pub.ECPubKey()
	if err != nil {
		return nil, err
	}

	privkey, err := key.ECPrivKey()
	if err != nil {
		return nil, err
	}

	witnessProg := btcutil.Hash160(pubkey.SerializeCompressed())
	p2wpkh, err := btcutil.NewAddressWitnessPubKeyHash(witnessProg, bitcoinNet)

	if err != nil {
		return nil, err
	}

	if g.NewAddr && p2wpkh.EncodeAddress() != lastAddr {
		return nil, fmt.Errorf("New address generated by clightning (%s) does not match derived address by the plugin (%s)", lastAddr, p2wpkh.EncodeAddress())
	}

	wif, err := btcutil.NewWIF(privkey, bitcoinNet, true)
	if err != nil {
		return nil, err
	}

	res := GetKeysResult{
		Wif:    wif.String(),
		Xpub:   pub.String(),
		Xpriv:  key.String(),
		Bech32: p2wpkh.EncodeAddress(),
	}
	if g.NewAddr {
		res.DerPath = strings.Join(dev_path[:], "/")
	}
	return res, nil
}

func (f *GetKeys) Name() string {
	return "getkeys"
}

func (f *GetKeys) New() interface{} {
	return &GetKeys{}
}
